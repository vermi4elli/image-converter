// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scene_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scene_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_scene_2eproto_metadata_getter(int index);
namespace scene_format {
class Camera;
struct CameraDefaultTypeInternal;
extern CameraDefaultTypeInternal _Camera_default_instance_;
class Color;
struct ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class Cube;
struct CubeDefaultTypeInternal;
extern CubeDefaultTypeInternal _Cube_default_instance_;
class CustomProperty;
struct CustomPropertyDefaultTypeInternal;
extern CustomPropertyDefaultTypeInternal _CustomProperty_default_instance_;
class Disk;
struct DiskDefaultTypeInternal;
extern DiskDefaultTypeInternal _Disk_default_instance_;
class LambertReflectionMaterial;
struct LambertReflectionMaterialDefaultTypeInternal;
extern LambertReflectionMaterialDefaultTypeInternal _LambertReflectionMaterial_default_instance_;
class Light;
struct LightDefaultTypeInternal;
extern LightDefaultTypeInternal _Light_default_instance_;
class LightDirectional;
struct LightDirectionalDefaultTypeInternal;
extern LightDirectionalDefaultTypeInternal _LightDirectional_default_instance_;
class LightEnvironment;
struct LightEnvironmentDefaultTypeInternal;
extern LightEnvironmentDefaultTypeInternal _LightEnvironment_default_instance_;
class LightPoint;
struct LightPointDefaultTypeInternal;
extern LightPointDefaultTypeInternal _LightPoint_default_instance_;
class LightSphere;
struct LightSphereDefaultTypeInternal;
extern LightSphereDefaultTypeInternal _LightSphere_default_instance_;
class Material;
struct MaterialDefaultTypeInternal;
extern MaterialDefaultTypeInternal _Material_default_instance_;
class MeshedObject;
struct MeshedObjectDefaultTypeInternal;
extern MeshedObjectDefaultTypeInternal _MeshedObject_default_instance_;
class OrthographicCamera;
struct OrthographicCameraDefaultTypeInternal;
extern OrthographicCameraDefaultTypeInternal _OrthographicCamera_default_instance_;
class PerspectiveCamera;
struct PerspectiveCameraDefaultTypeInternal;
extern PerspectiveCameraDefaultTypeInternal _PerspectiveCamera_default_instance_;
class Plane;
struct PlaneDefaultTypeInternal;
extern PlaneDefaultTypeInternal _Plane_default_instance_;
class RenderOptions;
struct RenderOptionsDefaultTypeInternal;
extern RenderOptionsDefaultTypeInternal _RenderOptions_default_instance_;
class Scene;
struct SceneDefaultTypeInternal;
extern SceneDefaultTypeInternal _Scene_default_instance_;
class SceneObject;
struct SceneObjectDefaultTypeInternal;
extern SceneObjectDefaultTypeInternal _SceneObject_default_instance_;
class SpecularReflectionMaterial;
struct SpecularReflectionMaterialDefaultTypeInternal;
extern SpecularReflectionMaterialDefaultTypeInternal _SpecularReflectionMaterial_default_instance_;
class Sphere;
struct SphereDefaultTypeInternal;
extern SphereDefaultTypeInternal _Sphere_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace scene_format
PROTOBUF_NAMESPACE_OPEN
template<> ::scene_format::Camera* Arena::CreateMaybeMessage<::scene_format::Camera>(Arena*);
template<> ::scene_format::Color* Arena::CreateMaybeMessage<::scene_format::Color>(Arena*);
template<> ::scene_format::Cube* Arena::CreateMaybeMessage<::scene_format::Cube>(Arena*);
template<> ::scene_format::CustomProperty* Arena::CreateMaybeMessage<::scene_format::CustomProperty>(Arena*);
template<> ::scene_format::Disk* Arena::CreateMaybeMessage<::scene_format::Disk>(Arena*);
template<> ::scene_format::LambertReflectionMaterial* Arena::CreateMaybeMessage<::scene_format::LambertReflectionMaterial>(Arena*);
template<> ::scene_format::Light* Arena::CreateMaybeMessage<::scene_format::Light>(Arena*);
template<> ::scene_format::LightDirectional* Arena::CreateMaybeMessage<::scene_format::LightDirectional>(Arena*);
template<> ::scene_format::LightEnvironment* Arena::CreateMaybeMessage<::scene_format::LightEnvironment>(Arena*);
template<> ::scene_format::LightPoint* Arena::CreateMaybeMessage<::scene_format::LightPoint>(Arena*);
template<> ::scene_format::LightSphere* Arena::CreateMaybeMessage<::scene_format::LightSphere>(Arena*);
template<> ::scene_format::Material* Arena::CreateMaybeMessage<::scene_format::Material>(Arena*);
template<> ::scene_format::MeshedObject* Arena::CreateMaybeMessage<::scene_format::MeshedObject>(Arena*);
template<> ::scene_format::OrthographicCamera* Arena::CreateMaybeMessage<::scene_format::OrthographicCamera>(Arena*);
template<> ::scene_format::PerspectiveCamera* Arena::CreateMaybeMessage<::scene_format::PerspectiveCamera>(Arena*);
template<> ::scene_format::Plane* Arena::CreateMaybeMessage<::scene_format::Plane>(Arena*);
template<> ::scene_format::RenderOptions* Arena::CreateMaybeMessage<::scene_format::RenderOptions>(Arena*);
template<> ::scene_format::Scene* Arena::CreateMaybeMessage<::scene_format::Scene>(Arena*);
template<> ::scene_format::SceneObject* Arena::CreateMaybeMessage<::scene_format::SceneObject>(Arena*);
template<> ::scene_format::SpecularReflectionMaterial* Arena::CreateMaybeMessage<::scene_format::SpecularReflectionMaterial>(Arena*);
template<> ::scene_format::Sphere* Arena::CreateMaybeMessage<::scene_format::Sphere>(Arena*);
template<> ::scene_format::Transform* Arena::CreateMaybeMessage<::scene_format::Transform>(Arena*);
template<> ::scene_format::Vector3* Arena::CreateMaybeMessage<::scene_format::Vector3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace scene_format {

// ===================================================================

class Scene PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Scene) */ {
 public:
  inline Scene() : Scene(nullptr) {}
  virtual ~Scene();
  explicit constexpr Scene(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Scene(const Scene& from);
  Scene(Scene&& from) noexcept
    : Scene() {
    *this = ::std::move(from);
  }

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scene& operator=(Scene&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Scene& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scene* internal_default_instance() {
    return reinterpret_cast<const Scene*>(
               &_Scene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Scene& a, Scene& b) {
    a.Swap(&b);
  }
  inline void Swap(Scene* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Scene* New() const final {
    return CreateMaybeMessage<Scene>(nullptr);
  }

  Scene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Scene>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scene* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Scene";
  }
  protected:
  explicit Scene(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSceneObjectsFieldNumber = 3,
    kLightsFieldNumber = 4,
    kCamerasFieldNumber = 5,
    kMaterialsFieldNumber = 6,
    kRenderOptionsFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated .scene_format.SceneObject scene_objects = 3;
  int scene_objects_size() const;
  private:
  int _internal_scene_objects_size() const;
  public:
  void clear_scene_objects();
  ::scene_format::SceneObject* mutable_scene_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::SceneObject >*
      mutable_scene_objects();
  private:
  const ::scene_format::SceneObject& _internal_scene_objects(int index) const;
  ::scene_format::SceneObject* _internal_add_scene_objects();
  public:
  const ::scene_format::SceneObject& scene_objects(int index) const;
  ::scene_format::SceneObject* add_scene_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::SceneObject >&
      scene_objects() const;

  // repeated .scene_format.Light lights = 4;
  int lights_size() const;
  private:
  int _internal_lights_size() const;
  public:
  void clear_lights();
  ::scene_format::Light* mutable_lights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Light >*
      mutable_lights();
  private:
  const ::scene_format::Light& _internal_lights(int index) const;
  ::scene_format::Light* _internal_add_lights();
  public:
  const ::scene_format::Light& lights(int index) const;
  ::scene_format::Light* add_lights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Light >&
      lights() const;

  // repeated .scene_format.Camera cameras = 5;
  int cameras_size() const;
  private:
  int _internal_cameras_size() const;
  public:
  void clear_cameras();
  ::scene_format::Camera* mutable_cameras(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Camera >*
      mutable_cameras();
  private:
  const ::scene_format::Camera& _internal_cameras(int index) const;
  ::scene_format::Camera* _internal_add_cameras();
  public:
  const ::scene_format::Camera& cameras(int index) const;
  ::scene_format::Camera* add_cameras();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Camera >&
      cameras() const;

  // repeated .scene_format.Material materials = 6;
  int materials_size() const;
  private:
  int _internal_materials_size() const;
  public:
  void clear_materials();
  ::scene_format::Material* mutable_materials(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Material >*
      mutable_materials();
  private:
  const ::scene_format::Material& _internal_materials(int index) const;
  ::scene_format::Material* _internal_add_materials();
  public:
  const ::scene_format::Material& materials(int index) const;
  ::scene_format::Material* add_materials();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Material >&
      materials() const;

  // .scene_format.RenderOptions render_options = 2;
  bool has_render_options() const;
  private:
  bool _internal_has_render_options() const;
  public:
  void clear_render_options();
  const ::scene_format::RenderOptions& render_options() const;
  ::scene_format::RenderOptions* release_render_options();
  ::scene_format::RenderOptions* mutable_render_options();
  void set_allocated_render_options(::scene_format::RenderOptions* render_options);
  private:
  const ::scene_format::RenderOptions& _internal_render_options() const;
  ::scene_format::RenderOptions* _internal_mutable_render_options();
  public:
  void unsafe_arena_set_allocated_render_options(
      ::scene_format::RenderOptions* render_options);
  ::scene_format::RenderOptions* unsafe_arena_release_render_options();

  // int32 version = 1;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.Scene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::SceneObject > scene_objects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Light > lights_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Camera > cameras_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Material > materials_;
  ::scene_format::RenderOptions* render_options_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Vector3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  virtual ~Vector3();
  explicit constexpr Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return CreateMaybeMessage<Vector3>(nullptr);
  }

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Color PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  virtual ~Color();
  explicit constexpr Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(nullptr);
  }

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // double r = 1;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double g = 2;
  void clear_g();
  double g() const;
  void set_g(double value);
  private:
  double _internal_g() const;
  void _internal_set_g(double value);
  public:

  // double b = 3;
  void clear_b();
  double b() const;
  void set_b(double value);
  private:
  double _internal_b() const;
  void _internal_set_b(double value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double r_;
  double g_;
  double b_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Transform PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  virtual ~Transform();
  explicit constexpr Transform(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transform(const Transform& from);
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transform* New() const final {
    return CreateMaybeMessage<Transform>(nullptr);
  }

  Transform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transform* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Transform";
  }
  protected:
  explicit Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kScaleFieldNumber = 4,
    kParentIdFieldNumber = 5,
  };
  // .scene_format.Vector3 position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::scene_format::Vector3& position() const;
  ::scene_format::Vector3* release_position();
  ::scene_format::Vector3* mutable_position();
  void set_allocated_position(::scene_format::Vector3* position);
  private:
  const ::scene_format::Vector3& _internal_position() const;
  ::scene_format::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::scene_format::Vector3* position);
  ::scene_format::Vector3* unsafe_arena_release_position();

  // .scene_format.Vector3 rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::scene_format::Vector3& rotation() const;
  ::scene_format::Vector3* release_rotation();
  ::scene_format::Vector3* mutable_rotation();
  void set_allocated_rotation(::scene_format::Vector3* rotation);
  private:
  const ::scene_format::Vector3& _internal_rotation() const;
  ::scene_format::Vector3* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::scene_format::Vector3* rotation);
  ::scene_format::Vector3* unsafe_arena_release_rotation();

  // .scene_format.Vector3 scale = 4;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::scene_format::Vector3& scale() const;
  ::scene_format::Vector3* release_scale();
  ::scene_format::Vector3* mutable_scale();
  void set_allocated_scale(::scene_format::Vector3* scale);
  private:
  const ::scene_format::Vector3& _internal_scale() const;
  ::scene_format::Vector3* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::scene_format::Vector3* scale);
  ::scene_format::Vector3* unsafe_arena_release_scale();

  // int32 parent_id = 5;
  void clear_parent_id();
  ::PROTOBUF_NAMESPACE_ID::int32 parent_id() const;
  void set_parent_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_parent_id() const;
  void _internal_set_parent_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.Transform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::scene_format::Vector3* position_;
  ::scene_format::Vector3* rotation_;
  ::scene_format::Vector3* scale_;
  ::PROTOBUF_NAMESPACE_ID::int32 parent_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class RenderOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.RenderOptions) */ {
 public:
  inline RenderOptions() : RenderOptions(nullptr) {}
  virtual ~RenderOptions();
  explicit constexpr RenderOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenderOptions(const RenderOptions& from);
  RenderOptions(RenderOptions&& from) noexcept
    : RenderOptions() {
    *this = ::std::move(from);
  }

  inline RenderOptions& operator=(const RenderOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenderOptions& operator=(RenderOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RenderOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenderOptions* internal_default_instance() {
    return reinterpret_cast<const RenderOptions*>(
               &_RenderOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RenderOptions& a, RenderOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(RenderOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenderOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RenderOptions* New() const final {
    return CreateMaybeMessage<RenderOptions>(nullptr);
  }

  RenderOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RenderOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RenderOptions& from);
  void MergeFrom(const RenderOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenderOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.RenderOptions";
  }
  protected:
  explicit RenderOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomPropertiesFieldNumber = 4,
    kCameraIdFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // repeated .scene_format.CustomProperty custom_properties = 4;
  int custom_properties_size() const;
  private:
  int _internal_custom_properties_size() const;
  public:
  void clear_custom_properties();
  ::scene_format::CustomProperty* mutable_custom_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::CustomProperty >*
      mutable_custom_properties();
  private:
  const ::scene_format::CustomProperty& _internal_custom_properties(int index) const;
  ::scene_format::CustomProperty* _internal_add_custom_properties();
  public:
  const ::scene_format::CustomProperty& custom_properties(int index) const;
  ::scene_format::CustomProperty* add_custom_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::CustomProperty >&
      custom_properties() const;

  // int32 camera_id = 1;
  void clear_camera_id();
  ::PROTOBUF_NAMESPACE_ID::int32 camera_id() const;
  void set_camera_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_camera_id() const;
  void _internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 width = 2;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 3;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.RenderOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::CustomProperty > custom_properties_;
  ::PROTOBUF_NAMESPACE_ID::int32 camera_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Cube PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Cube) */ {
 public:
  inline Cube() : Cube(nullptr) {}
  virtual ~Cube();
  explicit constexpr Cube(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cube(const Cube& from);
  Cube(Cube&& from) noexcept
    : Cube() {
    *this = ::std::move(from);
  }

  inline Cube& operator=(const Cube& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cube& operator=(Cube&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cube& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cube* internal_default_instance() {
    return reinterpret_cast<const Cube*>(
               &_Cube_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Cube& a, Cube& b) {
    a.Swap(&b);
  }
  inline void Swap(Cube* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cube* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cube* New() const final {
    return CreateMaybeMessage<Cube>(nullptr);
  }

  Cube* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cube>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cube& from);
  void MergeFrom(const Cube& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cube* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Cube";
  }
  protected:
  explicit Cube(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .scene_format.Vector3 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::scene_format::Vector3& size() const;
  ::scene_format::Vector3* release_size();
  ::scene_format::Vector3* mutable_size();
  void set_allocated_size(::scene_format::Vector3* size);
  private:
  const ::scene_format::Vector3& _internal_size() const;
  ::scene_format::Vector3* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::scene_format::Vector3* size);
  ::scene_format::Vector3* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:scene_format.Cube)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::scene_format::Vector3* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Sphere PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Sphere) */ {
 public:
  inline Sphere() : Sphere(nullptr) {}
  virtual ~Sphere();
  explicit constexpr Sphere(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sphere(const Sphere& from);
  Sphere(Sphere&& from) noexcept
    : Sphere() {
    *this = ::std::move(from);
  }

  inline Sphere& operator=(const Sphere& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sphere& operator=(Sphere&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Sphere& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sphere* internal_default_instance() {
    return reinterpret_cast<const Sphere*>(
               &_Sphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Sphere& a, Sphere& b) {
    a.Swap(&b);
  }
  inline void Swap(Sphere* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sphere* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sphere* New() const final {
    return CreateMaybeMessage<Sphere>(nullptr);
  }

  Sphere* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sphere>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Sphere& from);
  void MergeFrom(const Sphere& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sphere* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Sphere";
  }
  protected:
  explicit Sphere(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
  };
  // double radius = 1;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.Sphere)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Plane PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Plane) */ {
 public:
  inline Plane() : Plane(nullptr) {}
  virtual ~Plane();
  explicit constexpr Plane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plane(const Plane& from);
  Plane(Plane&& from) noexcept
    : Plane() {
    *this = ::std::move(from);
  }

  inline Plane& operator=(const Plane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plane& operator=(Plane&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Plane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plane* internal_default_instance() {
    return reinterpret_cast<const Plane*>(
               &_Plane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Plane& a, Plane& b) {
    a.Swap(&b);
  }
  inline void Swap(Plane* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Plane* New() const final {
    return CreateMaybeMessage<Plane>(nullptr);
  }

  Plane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plane>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Plane& from);
  void MergeFrom(const Plane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Plane";
  }
  protected:
  explicit Plane(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:scene_format.Plane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Disk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Disk) */ {
 public:
  inline Disk() : Disk(nullptr) {}
  virtual ~Disk();
  explicit constexpr Disk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Disk(const Disk& from);
  Disk(Disk&& from) noexcept
    : Disk() {
    *this = ::std::move(from);
  }

  inline Disk& operator=(const Disk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disk& operator=(Disk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Disk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Disk* internal_default_instance() {
    return reinterpret_cast<const Disk*>(
               &_Disk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Disk& a, Disk& b) {
    a.Swap(&b);
  }
  inline void Swap(Disk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Disk* New() const final {
    return CreateMaybeMessage<Disk>(nullptr);
  }

  Disk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Disk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Disk& from);
  void MergeFrom(const Disk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Disk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Disk";
  }
  protected:
  explicit Disk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
  };
  // double radius = 1;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.Disk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class MeshedObject PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.MeshedObject) */ {
 public:
  inline MeshedObject() : MeshedObject(nullptr) {}
  virtual ~MeshedObject();
  explicit constexpr MeshedObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeshedObject(const MeshedObject& from);
  MeshedObject(MeshedObject&& from) noexcept
    : MeshedObject() {
    *this = ::std::move(from);
  }

  inline MeshedObject& operator=(const MeshedObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshedObject& operator=(MeshedObject&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MeshedObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshedObject* internal_default_instance() {
    return reinterpret_cast<const MeshedObject*>(
               &_MeshedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MeshedObject& a, MeshedObject& b) {
    a.Swap(&b);
  }
  inline void Swap(MeshedObject* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshedObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeshedObject* New() const final {
    return CreateMaybeMessage<MeshedObject>(nullptr);
  }

  MeshedObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeshedObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MeshedObject& from);
  void MergeFrom(const MeshedObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeshedObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.MeshedObject";
  }
  protected:
  explicit MeshedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceFieldNumber = 2,
  };
  // string reference = 2;
  void clear_reference();
  const std::string& reference() const;
  void set_reference(const std::string& value);
  void set_reference(std::string&& value);
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  std::string* mutable_reference();
  std::string* release_reference();
  void set_allocated_reference(std::string* reference);
  private:
  const std::string& _internal_reference() const;
  void _internal_set_reference(const std::string& value);
  std::string* _internal_mutable_reference();
  public:

  // @@protoc_insertion_point(class_scope:scene_format.MeshedObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class SceneObject PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.SceneObject) */ {
 public:
  inline SceneObject() : SceneObject(nullptr) {}
  virtual ~SceneObject();
  explicit constexpr SceneObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SceneObject(const SceneObject& from);
  SceneObject(SceneObject&& from) noexcept
    : SceneObject() {
    *this = ::std::move(from);
  }

  inline SceneObject& operator=(const SceneObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneObject& operator=(SceneObject&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SceneObject& default_instance() {
    return *internal_default_instance();
  }
  enum ObjectMaterialCase {
    kMaterialId = 3,
    kMaterial = 4,
    OBJECT_MATERIAL_NOT_SET = 0,
  };

  enum MeshCase {
    kSphere = 5,
    kCube = 6,
    kPlane = 7,
    kDisk = 8,
    kMeshedObject = 9,
    MESH_NOT_SET = 0,
  };

  static inline const SceneObject* internal_default_instance() {
    return reinterpret_cast<const SceneObject*>(
               &_SceneObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SceneObject& a, SceneObject& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneObject* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SceneObject* New() const final {
    return CreateMaybeMessage<SceneObject>(nullptr);
  }

  SceneObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SceneObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SceneObject& from);
  void MergeFrom(const SceneObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.SceneObject";
  }
  protected:
  explicit SceneObject(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 2,
    kIdFieldNumber = 1,
    kMaterialIdFieldNumber = 3,
    kMaterialFieldNumber = 4,
    kSphereFieldNumber = 5,
    kCubeFieldNumber = 6,
    kPlaneFieldNumber = 7,
    kDiskFieldNumber = 8,
    kMeshedObjectFieldNumber = 9,
  };
  // .scene_format.Transform transform = 2;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::scene_format::Transform& transform() const;
  ::scene_format::Transform* release_transform();
  ::scene_format::Transform* mutable_transform();
  void set_allocated_transform(::scene_format::Transform* transform);
  private:
  const ::scene_format::Transform& _internal_transform() const;
  ::scene_format::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::scene_format::Transform* transform);
  ::scene_format::Transform* unsafe_arena_release_transform();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // string material_id = 3;
  bool has_material_id() const;
  private:
  bool _internal_has_material_id() const;
  public:
  void clear_material_id();
  const std::string& material_id() const;
  void set_material_id(const std::string& value);
  void set_material_id(std::string&& value);
  void set_material_id(const char* value);
  void set_material_id(const char* value, size_t size);
  std::string* mutable_material_id();
  std::string* release_material_id();
  void set_allocated_material_id(std::string* material_id);
  private:
  const std::string& _internal_material_id() const;
  void _internal_set_material_id(const std::string& value);
  std::string* _internal_mutable_material_id();
  public:

  // .scene_format.Material material = 4;
  bool has_material() const;
  private:
  bool _internal_has_material() const;
  public:
  void clear_material();
  const ::scene_format::Material& material() const;
  ::scene_format::Material* release_material();
  ::scene_format::Material* mutable_material();
  void set_allocated_material(::scene_format::Material* material);
  private:
  const ::scene_format::Material& _internal_material() const;
  ::scene_format::Material* _internal_mutable_material();
  public:
  void unsafe_arena_set_allocated_material(
      ::scene_format::Material* material);
  ::scene_format::Material* unsafe_arena_release_material();

  // .scene_format.Sphere sphere = 5;
  bool has_sphere() const;
  private:
  bool _internal_has_sphere() const;
  public:
  void clear_sphere();
  const ::scene_format::Sphere& sphere() const;
  ::scene_format::Sphere* release_sphere();
  ::scene_format::Sphere* mutable_sphere();
  void set_allocated_sphere(::scene_format::Sphere* sphere);
  private:
  const ::scene_format::Sphere& _internal_sphere() const;
  ::scene_format::Sphere* _internal_mutable_sphere();
  public:
  void unsafe_arena_set_allocated_sphere(
      ::scene_format::Sphere* sphere);
  ::scene_format::Sphere* unsafe_arena_release_sphere();

  // .scene_format.Cube cube = 6;
  bool has_cube() const;
  private:
  bool _internal_has_cube() const;
  public:
  void clear_cube();
  const ::scene_format::Cube& cube() const;
  ::scene_format::Cube* release_cube();
  ::scene_format::Cube* mutable_cube();
  void set_allocated_cube(::scene_format::Cube* cube);
  private:
  const ::scene_format::Cube& _internal_cube() const;
  ::scene_format::Cube* _internal_mutable_cube();
  public:
  void unsafe_arena_set_allocated_cube(
      ::scene_format::Cube* cube);
  ::scene_format::Cube* unsafe_arena_release_cube();

  // .scene_format.Plane plane = 7;
  bool has_plane() const;
  private:
  bool _internal_has_plane() const;
  public:
  void clear_plane();
  const ::scene_format::Plane& plane() const;
  ::scene_format::Plane* release_plane();
  ::scene_format::Plane* mutable_plane();
  void set_allocated_plane(::scene_format::Plane* plane);
  private:
  const ::scene_format::Plane& _internal_plane() const;
  ::scene_format::Plane* _internal_mutable_plane();
  public:
  void unsafe_arena_set_allocated_plane(
      ::scene_format::Plane* plane);
  ::scene_format::Plane* unsafe_arena_release_plane();

  // .scene_format.Disk disk = 8;
  bool has_disk() const;
  private:
  bool _internal_has_disk() const;
  public:
  void clear_disk();
  const ::scene_format::Disk& disk() const;
  ::scene_format::Disk* release_disk();
  ::scene_format::Disk* mutable_disk();
  void set_allocated_disk(::scene_format::Disk* disk);
  private:
  const ::scene_format::Disk& _internal_disk() const;
  ::scene_format::Disk* _internal_mutable_disk();
  public:
  void unsafe_arena_set_allocated_disk(
      ::scene_format::Disk* disk);
  ::scene_format::Disk* unsafe_arena_release_disk();

  // .scene_format.MeshedObject meshed_object = 9;
  bool has_meshed_object() const;
  private:
  bool _internal_has_meshed_object() const;
  public:
  void clear_meshed_object();
  const ::scene_format::MeshedObject& meshed_object() const;
  ::scene_format::MeshedObject* release_meshed_object();
  ::scene_format::MeshedObject* mutable_meshed_object();
  void set_allocated_meshed_object(::scene_format::MeshedObject* meshed_object);
  private:
  const ::scene_format::MeshedObject& _internal_meshed_object() const;
  ::scene_format::MeshedObject* _internal_mutable_meshed_object();
  public:
  void unsafe_arena_set_allocated_meshed_object(
      ::scene_format::MeshedObject* meshed_object);
  ::scene_format::MeshedObject* unsafe_arena_release_meshed_object();

  void clear_object_material();
  ObjectMaterialCase object_material_case() const;
  void clear_mesh();
  MeshCase mesh_case() const;
  // @@protoc_insertion_point(class_scope:scene_format.SceneObject)
 private:
  class _Internal;
  void set_has_material_id();
  void set_has_material();
  void set_has_sphere();
  void set_has_cube();
  void set_has_plane();
  void set_has_disk();
  void set_has_meshed_object();

  inline bool has_object_material() const;
  inline void clear_has_object_material();

  inline bool has_mesh() const;
  inline void clear_has_mesh();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::scene_format::Transform* transform_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  union ObjectMaterialUnion {
    constexpr ObjectMaterialUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr material_id_;
    ::scene_format::Material* material_;
  } object_material_;
  union MeshUnion {
    constexpr MeshUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::scene_format::Sphere* sphere_;
    ::scene_format::Cube* cube_;
    ::scene_format::Plane* plane_;
    ::scene_format::Disk* disk_;
    ::scene_format::MeshedObject* meshed_object_;
  } mesh_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[2];

  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class LightDirectional PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.LightDirectional) */ {
 public:
  inline LightDirectional() : LightDirectional(nullptr) {}
  virtual ~LightDirectional();
  explicit constexpr LightDirectional(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LightDirectional(const LightDirectional& from);
  LightDirectional(LightDirectional&& from) noexcept
    : LightDirectional() {
    *this = ::std::move(from);
  }

  inline LightDirectional& operator=(const LightDirectional& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightDirectional& operator=(LightDirectional&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LightDirectional& default_instance() {
    return *internal_default_instance();
  }
  static inline const LightDirectional* internal_default_instance() {
    return reinterpret_cast<const LightDirectional*>(
               &_LightDirectional_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LightDirectional& a, LightDirectional& b) {
    a.Swap(&b);
  }
  inline void Swap(LightDirectional* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightDirectional* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LightDirectional* New() const final {
    return CreateMaybeMessage<LightDirectional>(nullptr);
  }

  LightDirectional* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LightDirectional>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LightDirectional& from);
  void MergeFrom(const LightDirectional& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightDirectional* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.LightDirectional";
  }
  protected:
  explicit LightDirectional(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:scene_format.LightDirectional)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class LightPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.LightPoint) */ {
 public:
  inline LightPoint() : LightPoint(nullptr) {}
  virtual ~LightPoint();
  explicit constexpr LightPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LightPoint(const LightPoint& from);
  LightPoint(LightPoint&& from) noexcept
    : LightPoint() {
    *this = ::std::move(from);
  }

  inline LightPoint& operator=(const LightPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightPoint& operator=(LightPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LightPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LightPoint* internal_default_instance() {
    return reinterpret_cast<const LightPoint*>(
               &_LightPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LightPoint& a, LightPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(LightPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LightPoint* New() const final {
    return CreateMaybeMessage<LightPoint>(nullptr);
  }

  LightPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LightPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LightPoint& from);
  void MergeFrom(const LightPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.LightPoint";
  }
  protected:
  explicit LightPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:scene_format.LightPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class LightEnvironment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.LightEnvironment) */ {
 public:
  inline LightEnvironment() : LightEnvironment(nullptr) {}
  virtual ~LightEnvironment();
  explicit constexpr LightEnvironment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LightEnvironment(const LightEnvironment& from);
  LightEnvironment(LightEnvironment&& from) noexcept
    : LightEnvironment() {
    *this = ::std::move(from);
  }

  inline LightEnvironment& operator=(const LightEnvironment& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightEnvironment& operator=(LightEnvironment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LightEnvironment& default_instance() {
    return *internal_default_instance();
  }
  static inline const LightEnvironment* internal_default_instance() {
    return reinterpret_cast<const LightEnvironment*>(
               &_LightEnvironment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LightEnvironment& a, LightEnvironment& b) {
    a.Swap(&b);
  }
  inline void Swap(LightEnvironment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightEnvironment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LightEnvironment* New() const final {
    return CreateMaybeMessage<LightEnvironment>(nullptr);
  }

  LightEnvironment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LightEnvironment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LightEnvironment& from);
  void MergeFrom(const LightEnvironment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightEnvironment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.LightEnvironment";
  }
  protected:
  explicit LightEnvironment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:scene_format.LightEnvironment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class LightSphere PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.LightSphere) */ {
 public:
  inline LightSphere() : LightSphere(nullptr) {}
  virtual ~LightSphere();
  explicit constexpr LightSphere(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LightSphere(const LightSphere& from);
  LightSphere(LightSphere&& from) noexcept
    : LightSphere() {
    *this = ::std::move(from);
  }

  inline LightSphere& operator=(const LightSphere& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightSphere& operator=(LightSphere&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LightSphere& default_instance() {
    return *internal_default_instance();
  }
  static inline const LightSphere* internal_default_instance() {
    return reinterpret_cast<const LightSphere*>(
               &_LightSphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LightSphere& a, LightSphere& b) {
    a.Swap(&b);
  }
  inline void Swap(LightSphere* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightSphere* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LightSphere* New() const final {
    return CreateMaybeMessage<LightSphere>(nullptr);
  }

  LightSphere* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LightSphere>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LightSphere& from);
  void MergeFrom(const LightSphere& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightSphere* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.LightSphere";
  }
  protected:
  explicit LightSphere(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
  };
  // double radius = 1;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.LightSphere)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Light PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Light) */ {
 public:
  inline Light() : Light(nullptr) {}
  virtual ~Light();
  explicit constexpr Light(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Light(const Light& from);
  Light(Light&& from) noexcept
    : Light() {
    *this = ::std::move(from);
  }

  inline Light& operator=(const Light& from) {
    CopyFrom(from);
    return *this;
  }
  inline Light& operator=(Light&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Light& default_instance() {
    return *internal_default_instance();
  }
  enum LightCase {
    kPoint = 5,
    kDirectional = 6,
    kSphere = 7,
    kEnvironment = 8,
    LIGHT_NOT_SET = 0,
  };

  static inline const Light* internal_default_instance() {
    return reinterpret_cast<const Light*>(
               &_Light_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Light& a, Light& b) {
    a.Swap(&b);
  }
  inline void Swap(Light* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Light* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Light* New() const final {
    return CreateMaybeMessage<Light>(nullptr);
  }

  Light* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Light>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Light& from);
  void MergeFrom(const Light& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Light* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Light";
  }
  protected:
  explicit Light(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 3,
    kColorFieldNumber = 4,
    kIdFieldNumber = 1,
    kPointFieldNumber = 5,
    kDirectionalFieldNumber = 6,
    kSphereFieldNumber = 7,
    kEnvironmentFieldNumber = 8,
  };
  // .scene_format.Transform transform = 3;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::scene_format::Transform& transform() const;
  ::scene_format::Transform* release_transform();
  ::scene_format::Transform* mutable_transform();
  void set_allocated_transform(::scene_format::Transform* transform);
  private:
  const ::scene_format::Transform& _internal_transform() const;
  ::scene_format::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::scene_format::Transform* transform);
  ::scene_format::Transform* unsafe_arena_release_transform();

  // .scene_format.Color color = 4;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::scene_format::Color& color() const;
  ::scene_format::Color* release_color();
  ::scene_format::Color* mutable_color();
  void set_allocated_color(::scene_format::Color* color);
  private:
  const ::scene_format::Color& _internal_color() const;
  ::scene_format::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::scene_format::Color* color);
  ::scene_format::Color* unsafe_arena_release_color();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .scene_format.LightPoint point = 5;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::scene_format::LightPoint& point() const;
  ::scene_format::LightPoint* release_point();
  ::scene_format::LightPoint* mutable_point();
  void set_allocated_point(::scene_format::LightPoint* point);
  private:
  const ::scene_format::LightPoint& _internal_point() const;
  ::scene_format::LightPoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::scene_format::LightPoint* point);
  ::scene_format::LightPoint* unsafe_arena_release_point();

  // .scene_format.LightDirectional directional = 6;
  bool has_directional() const;
  private:
  bool _internal_has_directional() const;
  public:
  void clear_directional();
  const ::scene_format::LightDirectional& directional() const;
  ::scene_format::LightDirectional* release_directional();
  ::scene_format::LightDirectional* mutable_directional();
  void set_allocated_directional(::scene_format::LightDirectional* directional);
  private:
  const ::scene_format::LightDirectional& _internal_directional() const;
  ::scene_format::LightDirectional* _internal_mutable_directional();
  public:
  void unsafe_arena_set_allocated_directional(
      ::scene_format::LightDirectional* directional);
  ::scene_format::LightDirectional* unsafe_arena_release_directional();

  // .scene_format.LightSphere sphere = 7;
  bool has_sphere() const;
  private:
  bool _internal_has_sphere() const;
  public:
  void clear_sphere();
  const ::scene_format::LightSphere& sphere() const;
  ::scene_format::LightSphere* release_sphere();
  ::scene_format::LightSphere* mutable_sphere();
  void set_allocated_sphere(::scene_format::LightSphere* sphere);
  private:
  const ::scene_format::LightSphere& _internal_sphere() const;
  ::scene_format::LightSphere* _internal_mutable_sphere();
  public:
  void unsafe_arena_set_allocated_sphere(
      ::scene_format::LightSphere* sphere);
  ::scene_format::LightSphere* unsafe_arena_release_sphere();

  // .scene_format.LightEnvironment environment = 8;
  bool has_environment() const;
  private:
  bool _internal_has_environment() const;
  public:
  void clear_environment();
  const ::scene_format::LightEnvironment& environment() const;
  ::scene_format::LightEnvironment* release_environment();
  ::scene_format::LightEnvironment* mutable_environment();
  void set_allocated_environment(::scene_format::LightEnvironment* environment);
  private:
  const ::scene_format::LightEnvironment& _internal_environment() const;
  ::scene_format::LightEnvironment* _internal_mutable_environment();
  public:
  void unsafe_arena_set_allocated_environment(
      ::scene_format::LightEnvironment* environment);
  ::scene_format::LightEnvironment* unsafe_arena_release_environment();

  void clear_light();
  LightCase light_case() const;
  // @@protoc_insertion_point(class_scope:scene_format.Light)
 private:
  class _Internal;
  void set_has_point();
  void set_has_directional();
  void set_has_sphere();
  void set_has_environment();

  inline bool has_light() const;
  inline void clear_has_light();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::scene_format::Transform* transform_;
  ::scene_format::Color* color_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  union LightUnion {
    constexpr LightUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::scene_format::LightPoint* point_;
    ::scene_format::LightDirectional* directional_;
    ::scene_format::LightSphere* sphere_;
    ::scene_format::LightEnvironment* environment_;
  } light_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class PerspectiveCamera PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.PerspectiveCamera) */ {
 public:
  inline PerspectiveCamera() : PerspectiveCamera(nullptr) {}
  virtual ~PerspectiveCamera();
  explicit constexpr PerspectiveCamera(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerspectiveCamera(const PerspectiveCamera& from);
  PerspectiveCamera(PerspectiveCamera&& from) noexcept
    : PerspectiveCamera() {
    *this = ::std::move(from);
  }

  inline PerspectiveCamera& operator=(const PerspectiveCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerspectiveCamera& operator=(PerspectiveCamera&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PerspectiveCamera& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerspectiveCamera* internal_default_instance() {
    return reinterpret_cast<const PerspectiveCamera*>(
               &_PerspectiveCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PerspectiveCamera& a, PerspectiveCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(PerspectiveCamera* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerspectiveCamera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PerspectiveCamera* New() const final {
    return CreateMaybeMessage<PerspectiveCamera>(nullptr);
  }

  PerspectiveCamera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PerspectiveCamera>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PerspectiveCamera& from);
  void MergeFrom(const PerspectiveCamera& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerspectiveCamera* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.PerspectiveCamera";
  }
  protected:
  explicit PerspectiveCamera(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFovFieldNumber = 1,
  };
  // double fov = 1;
  void clear_fov();
  double fov() const;
  void set_fov(double value);
  private:
  double _internal_fov() const;
  void _internal_set_fov(double value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.PerspectiveCamera)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double fov_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class OrthographicCamera PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.OrthographicCamera) */ {
 public:
  inline OrthographicCamera() : OrthographicCamera(nullptr) {}
  virtual ~OrthographicCamera();
  explicit constexpr OrthographicCamera(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrthographicCamera(const OrthographicCamera& from);
  OrthographicCamera(OrthographicCamera&& from) noexcept
    : OrthographicCamera() {
    *this = ::std::move(from);
  }

  inline OrthographicCamera& operator=(const OrthographicCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrthographicCamera& operator=(OrthographicCamera&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrthographicCamera& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrthographicCamera* internal_default_instance() {
    return reinterpret_cast<const OrthographicCamera*>(
               &_OrthographicCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(OrthographicCamera& a, OrthographicCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(OrthographicCamera* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrthographicCamera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrthographicCamera* New() const final {
    return CreateMaybeMessage<OrthographicCamera>(nullptr);
  }

  OrthographicCamera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrthographicCamera>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrthographicCamera& from);
  void MergeFrom(const OrthographicCamera& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrthographicCamera* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.OrthographicCamera";
  }
  protected:
  explicit OrthographicCamera(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:scene_format.OrthographicCamera)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Camera PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Camera) */ {
 public:
  inline Camera() : Camera(nullptr) {}
  virtual ~Camera();
  explicit constexpr Camera(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Camera(const Camera& from);
  Camera(Camera&& from) noexcept
    : Camera() {
    *this = ::std::move(from);
  }

  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }
  inline Camera& operator=(Camera&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Camera& default_instance() {
    return *internal_default_instance();
  }
  enum CameraCase {
    kPerspective = 3,
    kOrthographic = 4,
    CAMERA_NOT_SET = 0,
  };

  static inline const Camera* internal_default_instance() {
    return reinterpret_cast<const Camera*>(
               &_Camera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Camera& a, Camera& b) {
    a.Swap(&b);
  }
  inline void Swap(Camera* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Camera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Camera* New() const final {
    return CreateMaybeMessage<Camera>(nullptr);
  }

  Camera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Camera>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Camera& from);
  void MergeFrom(const Camera& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Camera* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Camera";
  }
  protected:
  explicit Camera(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 2,
    kIdFieldNumber = 1,
    kPerspectiveFieldNumber = 3,
    kOrthographicFieldNumber = 4,
  };
  // .scene_format.Transform transform = 2;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::scene_format::Transform& transform() const;
  ::scene_format::Transform* release_transform();
  ::scene_format::Transform* mutable_transform();
  void set_allocated_transform(::scene_format::Transform* transform);
  private:
  const ::scene_format::Transform& _internal_transform() const;
  ::scene_format::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::scene_format::Transform* transform);
  ::scene_format::Transform* unsafe_arena_release_transform();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .scene_format.PerspectiveCamera perspective = 3;
  bool has_perspective() const;
  private:
  bool _internal_has_perspective() const;
  public:
  void clear_perspective();
  const ::scene_format::PerspectiveCamera& perspective() const;
  ::scene_format::PerspectiveCamera* release_perspective();
  ::scene_format::PerspectiveCamera* mutable_perspective();
  void set_allocated_perspective(::scene_format::PerspectiveCamera* perspective);
  private:
  const ::scene_format::PerspectiveCamera& _internal_perspective() const;
  ::scene_format::PerspectiveCamera* _internal_mutable_perspective();
  public:
  void unsafe_arena_set_allocated_perspective(
      ::scene_format::PerspectiveCamera* perspective);
  ::scene_format::PerspectiveCamera* unsafe_arena_release_perspective();

  // .scene_format.OrthographicCamera orthographic = 4;
  bool has_orthographic() const;
  private:
  bool _internal_has_orthographic() const;
  public:
  void clear_orthographic();
  const ::scene_format::OrthographicCamera& orthographic() const;
  ::scene_format::OrthographicCamera* release_orthographic();
  ::scene_format::OrthographicCamera* mutable_orthographic();
  void set_allocated_orthographic(::scene_format::OrthographicCamera* orthographic);
  private:
  const ::scene_format::OrthographicCamera& _internal_orthographic() const;
  ::scene_format::OrthographicCamera* _internal_mutable_orthographic();
  public:
  void unsafe_arena_set_allocated_orthographic(
      ::scene_format::OrthographicCamera* orthographic);
  ::scene_format::OrthographicCamera* unsafe_arena_release_orthographic();

  void clear_camera();
  CameraCase camera_case() const;
  // @@protoc_insertion_point(class_scope:scene_format.Camera)
 private:
  class _Internal;
  void set_has_perspective();
  void set_has_orthographic();

  inline bool has_camera() const;
  inline void clear_has_camera();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::scene_format::Transform* transform_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  union CameraUnion {
    constexpr CameraUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::scene_format::PerspectiveCamera* perspective_;
    ::scene_format::OrthographicCamera* orthographic_;
  } camera_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Material PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.Material) */ {
 public:
  inline Material() : Material(nullptr) {}
  virtual ~Material();
  explicit constexpr Material(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Material(const Material& from);
  Material(Material&& from) noexcept
    : Material() {
    *this = ::std::move(from);
  }

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }
  inline Material& operator=(Material&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Material& default_instance() {
    return *internal_default_instance();
  }
  enum MaterialCase {
    kLambertReflection = 2,
    kSpecularReflection = 3,
    MATERIAL_NOT_SET = 0,
  };

  static inline const Material* internal_default_instance() {
    return reinterpret_cast<const Material*>(
               &_Material_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Material& a, Material& b) {
    a.Swap(&b);
  }
  inline void Swap(Material* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Material* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Material* New() const final {
    return CreateMaybeMessage<Material>(nullptr);
  }

  Material* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Material>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Material* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.Material";
  }
  protected:
  explicit Material(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLambertReflectionFieldNumber = 2,
    kSpecularReflectionFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .scene_format.LambertReflectionMaterial lambert_reflection = 2;
  bool has_lambert_reflection() const;
  private:
  bool _internal_has_lambert_reflection() const;
  public:
  void clear_lambert_reflection();
  const ::scene_format::LambertReflectionMaterial& lambert_reflection() const;
  ::scene_format::LambertReflectionMaterial* release_lambert_reflection();
  ::scene_format::LambertReflectionMaterial* mutable_lambert_reflection();
  void set_allocated_lambert_reflection(::scene_format::LambertReflectionMaterial* lambert_reflection);
  private:
  const ::scene_format::LambertReflectionMaterial& _internal_lambert_reflection() const;
  ::scene_format::LambertReflectionMaterial* _internal_mutable_lambert_reflection();
  public:
  void unsafe_arena_set_allocated_lambert_reflection(
      ::scene_format::LambertReflectionMaterial* lambert_reflection);
  ::scene_format::LambertReflectionMaterial* unsafe_arena_release_lambert_reflection();

  // .scene_format.SpecularReflectionMaterial specular_reflection = 3;
  bool has_specular_reflection() const;
  private:
  bool _internal_has_specular_reflection() const;
  public:
  void clear_specular_reflection();
  const ::scene_format::SpecularReflectionMaterial& specular_reflection() const;
  ::scene_format::SpecularReflectionMaterial* release_specular_reflection();
  ::scene_format::SpecularReflectionMaterial* mutable_specular_reflection();
  void set_allocated_specular_reflection(::scene_format::SpecularReflectionMaterial* specular_reflection);
  private:
  const ::scene_format::SpecularReflectionMaterial& _internal_specular_reflection() const;
  ::scene_format::SpecularReflectionMaterial* _internal_mutable_specular_reflection();
  public:
  void unsafe_arena_set_allocated_specular_reflection(
      ::scene_format::SpecularReflectionMaterial* specular_reflection);
  ::scene_format::SpecularReflectionMaterial* unsafe_arena_release_specular_reflection();

  void clear_material();
  MaterialCase material_case() const;
  // @@protoc_insertion_point(class_scope:scene_format.Material)
 private:
  class _Internal;
  void set_has_lambert_reflection();
  void set_has_specular_reflection();

  inline bool has_material() const;
  inline void clear_has_material();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  union MaterialUnion {
    constexpr MaterialUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::scene_format::LambertReflectionMaterial* lambert_reflection_;
    ::scene_format::SpecularReflectionMaterial* specular_reflection_;
  } material_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class LambertReflectionMaterial PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.LambertReflectionMaterial) */ {
 public:
  inline LambertReflectionMaterial() : LambertReflectionMaterial(nullptr) {}
  virtual ~LambertReflectionMaterial();
  explicit constexpr LambertReflectionMaterial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LambertReflectionMaterial(const LambertReflectionMaterial& from);
  LambertReflectionMaterial(LambertReflectionMaterial&& from) noexcept
    : LambertReflectionMaterial() {
    *this = ::std::move(from);
  }

  inline LambertReflectionMaterial& operator=(const LambertReflectionMaterial& from) {
    CopyFrom(from);
    return *this;
  }
  inline LambertReflectionMaterial& operator=(LambertReflectionMaterial&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LambertReflectionMaterial& default_instance() {
    return *internal_default_instance();
  }
  static inline const LambertReflectionMaterial* internal_default_instance() {
    return reinterpret_cast<const LambertReflectionMaterial*>(
               &_LambertReflectionMaterial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LambertReflectionMaterial& a, LambertReflectionMaterial& b) {
    a.Swap(&b);
  }
  inline void Swap(LambertReflectionMaterial* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LambertReflectionMaterial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LambertReflectionMaterial* New() const final {
    return CreateMaybeMessage<LambertReflectionMaterial>(nullptr);
  }

  LambertReflectionMaterial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LambertReflectionMaterial>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LambertReflectionMaterial& from);
  void MergeFrom(const LambertReflectionMaterial& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LambertReflectionMaterial* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.LambertReflectionMaterial";
  }
  protected:
  explicit LambertReflectionMaterial(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // .scene_format.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::scene_format::Color& color() const;
  ::scene_format::Color* release_color();
  ::scene_format::Color* mutable_color();
  void set_allocated_color(::scene_format::Color* color);
  private:
  const ::scene_format::Color& _internal_color() const;
  ::scene_format::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::scene_format::Color* color);
  ::scene_format::Color* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:scene_format.LambertReflectionMaterial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::scene_format::Color* color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class SpecularReflectionMaterial PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.SpecularReflectionMaterial) */ {
 public:
  inline SpecularReflectionMaterial() : SpecularReflectionMaterial(nullptr) {}
  virtual ~SpecularReflectionMaterial();
  explicit constexpr SpecularReflectionMaterial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecularReflectionMaterial(const SpecularReflectionMaterial& from);
  SpecularReflectionMaterial(SpecularReflectionMaterial&& from) noexcept
    : SpecularReflectionMaterial() {
    *this = ::std::move(from);
  }

  inline SpecularReflectionMaterial& operator=(const SpecularReflectionMaterial& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecularReflectionMaterial& operator=(SpecularReflectionMaterial&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpecularReflectionMaterial& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecularReflectionMaterial* internal_default_instance() {
    return reinterpret_cast<const SpecularReflectionMaterial*>(
               &_SpecularReflectionMaterial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SpecularReflectionMaterial& a, SpecularReflectionMaterial& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecularReflectionMaterial* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecularReflectionMaterial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpecularReflectionMaterial* New() const final {
    return CreateMaybeMessage<SpecularReflectionMaterial>(nullptr);
  }

  SpecularReflectionMaterial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpecularReflectionMaterial>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpecularReflectionMaterial& from);
  void MergeFrom(const SpecularReflectionMaterial& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecularReflectionMaterial* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.SpecularReflectionMaterial";
  }
  protected:
  explicit SpecularReflectionMaterial(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEtaFieldNumber = 1,
  };
  // double eta = 1;
  void clear_eta();
  double eta() const;
  void set_eta(double value);
  private:
  double _internal_eta() const;
  void _internal_set_eta(double value);
  public:

  // @@protoc_insertion_point(class_scope:scene_format.SpecularReflectionMaterial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double eta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class CustomProperty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scene_format.CustomProperty) */ {
 public:
  inline CustomProperty() : CustomProperty(nullptr) {}
  virtual ~CustomProperty();
  explicit constexpr CustomProperty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomProperty(const CustomProperty& from);
  CustomProperty(CustomProperty&& from) noexcept
    : CustomProperty() {
    *this = ::std::move(from);
  }

  inline CustomProperty& operator=(const CustomProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomProperty& operator=(CustomProperty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomProperty& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kTextValue = 2,
    kInt32Value = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const CustomProperty* internal_default_instance() {
    return reinterpret_cast<const CustomProperty*>(
               &_CustomProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CustomProperty& a, CustomProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomProperty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomProperty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomProperty* New() const final {
    return CreateMaybeMessage<CustomProperty>(nullptr);
  }

  CustomProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomProperty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomProperty& from);
  void MergeFrom(const CustomProperty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomProperty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scene_format.CustomProperty";
  }
  protected:
  explicit CustomProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_scene_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kTextValueFieldNumber = 2,
    kInt32ValueFieldNumber = 3,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string text_value = 2;
  bool has_text_value() const;
  private:
  bool _internal_has_text_value() const;
  public:
  void clear_text_value();
  const std::string& text_value() const;
  void set_text_value(const std::string& value);
  void set_text_value(std::string&& value);
  void set_text_value(const char* value);
  void set_text_value(const char* value, size_t size);
  std::string* mutable_text_value();
  std::string* release_text_value();
  void set_allocated_text_value(std::string* text_value);
  private:
  const std::string& _internal_text_value() const;
  void _internal_set_text_value(const std::string& value);
  std::string* _internal_mutable_text_value();
  public:

  // int32 int32_value = 3;
  bool has_int32_value() const;
  private:
  bool _internal_has_int32_value() const;
  public:
  void clear_int32_value();
  ::PROTOBUF_NAMESPACE_ID::int32 int32_value() const;
  void set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_int32_value() const;
  void _internal_set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:scene_format.CustomProperty)
 private:
  class _Internal;
  void set_has_text_value();
  void set_has_int32_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_value_;
    ::PROTOBUF_NAMESPACE_ID::int32 int32_value_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scene_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Scene

// int32 version = 1;
inline void Scene::clear_version() {
  version_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Scene::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Scene::version() const {
  // @@protoc_insertion_point(field_get:scene_format.Scene.version)
  return _internal_version();
}
inline void Scene::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  version_ = value;
}
inline void Scene::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:scene_format.Scene.version)
}

// .scene_format.RenderOptions render_options = 2;
inline bool Scene::_internal_has_render_options() const {
  return this != internal_default_instance() && render_options_ != nullptr;
}
inline bool Scene::has_render_options() const {
  return _internal_has_render_options();
}
inline void Scene::clear_render_options() {
  if (GetArena() == nullptr && render_options_ != nullptr) {
    delete render_options_;
  }
  render_options_ = nullptr;
}
inline const ::scene_format::RenderOptions& Scene::_internal_render_options() const {
  const ::scene_format::RenderOptions* p = render_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::RenderOptions&>(
      ::scene_format::_RenderOptions_default_instance_);
}
inline const ::scene_format::RenderOptions& Scene::render_options() const {
  // @@protoc_insertion_point(field_get:scene_format.Scene.render_options)
  return _internal_render_options();
}
inline void Scene::unsafe_arena_set_allocated_render_options(
    ::scene_format::RenderOptions* render_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(render_options_);
  }
  render_options_ = render_options;
  if (render_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Scene.render_options)
}
inline ::scene_format::RenderOptions* Scene::release_render_options() {
  
  ::scene_format::RenderOptions* temp = render_options_;
  render_options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::RenderOptions* Scene::unsafe_arena_release_render_options() {
  // @@protoc_insertion_point(field_release:scene_format.Scene.render_options)
  
  ::scene_format::RenderOptions* temp = render_options_;
  render_options_ = nullptr;
  return temp;
}
inline ::scene_format::RenderOptions* Scene::_internal_mutable_render_options() {
  
  if (render_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::RenderOptions>(GetArena());
    render_options_ = p;
  }
  return render_options_;
}
inline ::scene_format::RenderOptions* Scene::mutable_render_options() {
  // @@protoc_insertion_point(field_mutable:scene_format.Scene.render_options)
  return _internal_mutable_render_options();
}
inline void Scene::set_allocated_render_options(::scene_format::RenderOptions* render_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete render_options_;
  }
  if (render_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(render_options);
    if (message_arena != submessage_arena) {
      render_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, render_options, submessage_arena);
    }
    
  } else {
    
  }
  render_options_ = render_options;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Scene.render_options)
}

// repeated .scene_format.SceneObject scene_objects = 3;
inline int Scene::_internal_scene_objects_size() const {
  return scene_objects_.size();
}
inline int Scene::scene_objects_size() const {
  return _internal_scene_objects_size();
}
inline void Scene::clear_scene_objects() {
  scene_objects_.Clear();
}
inline ::scene_format::SceneObject* Scene::mutable_scene_objects(int index) {
  // @@protoc_insertion_point(field_mutable:scene_format.Scene.scene_objects)
  return scene_objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::SceneObject >*
Scene::mutable_scene_objects() {
  // @@protoc_insertion_point(field_mutable_list:scene_format.Scene.scene_objects)
  return &scene_objects_;
}
inline const ::scene_format::SceneObject& Scene::_internal_scene_objects(int index) const {
  return scene_objects_.Get(index);
}
inline const ::scene_format::SceneObject& Scene::scene_objects(int index) const {
  // @@protoc_insertion_point(field_get:scene_format.Scene.scene_objects)
  return _internal_scene_objects(index);
}
inline ::scene_format::SceneObject* Scene::_internal_add_scene_objects() {
  return scene_objects_.Add();
}
inline ::scene_format::SceneObject* Scene::add_scene_objects() {
  // @@protoc_insertion_point(field_add:scene_format.Scene.scene_objects)
  return _internal_add_scene_objects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::SceneObject >&
Scene::scene_objects() const {
  // @@protoc_insertion_point(field_list:scene_format.Scene.scene_objects)
  return scene_objects_;
}

// repeated .scene_format.Light lights = 4;
inline int Scene::_internal_lights_size() const {
  return lights_.size();
}
inline int Scene::lights_size() const {
  return _internal_lights_size();
}
inline void Scene::clear_lights() {
  lights_.Clear();
}
inline ::scene_format::Light* Scene::mutable_lights(int index) {
  // @@protoc_insertion_point(field_mutable:scene_format.Scene.lights)
  return lights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Light >*
Scene::mutable_lights() {
  // @@protoc_insertion_point(field_mutable_list:scene_format.Scene.lights)
  return &lights_;
}
inline const ::scene_format::Light& Scene::_internal_lights(int index) const {
  return lights_.Get(index);
}
inline const ::scene_format::Light& Scene::lights(int index) const {
  // @@protoc_insertion_point(field_get:scene_format.Scene.lights)
  return _internal_lights(index);
}
inline ::scene_format::Light* Scene::_internal_add_lights() {
  return lights_.Add();
}
inline ::scene_format::Light* Scene::add_lights() {
  // @@protoc_insertion_point(field_add:scene_format.Scene.lights)
  return _internal_add_lights();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Light >&
Scene::lights() const {
  // @@protoc_insertion_point(field_list:scene_format.Scene.lights)
  return lights_;
}

// repeated .scene_format.Camera cameras = 5;
inline int Scene::_internal_cameras_size() const {
  return cameras_.size();
}
inline int Scene::cameras_size() const {
  return _internal_cameras_size();
}
inline void Scene::clear_cameras() {
  cameras_.Clear();
}
inline ::scene_format::Camera* Scene::mutable_cameras(int index) {
  // @@protoc_insertion_point(field_mutable:scene_format.Scene.cameras)
  return cameras_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Camera >*
Scene::mutable_cameras() {
  // @@protoc_insertion_point(field_mutable_list:scene_format.Scene.cameras)
  return &cameras_;
}
inline const ::scene_format::Camera& Scene::_internal_cameras(int index) const {
  return cameras_.Get(index);
}
inline const ::scene_format::Camera& Scene::cameras(int index) const {
  // @@protoc_insertion_point(field_get:scene_format.Scene.cameras)
  return _internal_cameras(index);
}
inline ::scene_format::Camera* Scene::_internal_add_cameras() {
  return cameras_.Add();
}
inline ::scene_format::Camera* Scene::add_cameras() {
  // @@protoc_insertion_point(field_add:scene_format.Scene.cameras)
  return _internal_add_cameras();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Camera >&
Scene::cameras() const {
  // @@protoc_insertion_point(field_list:scene_format.Scene.cameras)
  return cameras_;
}

// repeated .scene_format.Material materials = 6;
inline int Scene::_internal_materials_size() const {
  return materials_.size();
}
inline int Scene::materials_size() const {
  return _internal_materials_size();
}
inline void Scene::clear_materials() {
  materials_.Clear();
}
inline ::scene_format::Material* Scene::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:scene_format.Scene.materials)
  return materials_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Material >*
Scene::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:scene_format.Scene.materials)
  return &materials_;
}
inline const ::scene_format::Material& Scene::_internal_materials(int index) const {
  return materials_.Get(index);
}
inline const ::scene_format::Material& Scene::materials(int index) const {
  // @@protoc_insertion_point(field_get:scene_format.Scene.materials)
  return _internal_materials(index);
}
inline ::scene_format::Material* Scene::_internal_add_materials() {
  return materials_.Add();
}
inline ::scene_format::Material* Scene::add_materials() {
  // @@protoc_insertion_point(field_add:scene_format.Scene.materials)
  return _internal_add_materials();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::Material >&
Scene::materials() const {
  // @@protoc_insertion_point(field_list:scene_format.Scene.materials)
  return materials_;
}

// -------------------------------------------------------------------

// Vector3

// double x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline double Vector3::_internal_x() const {
  return x_;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:scene_format.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vector3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:scene_format.Vector3.x)
}

// double y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline double Vector3::_internal_y() const {
  return y_;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:scene_format.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vector3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:scene_format.Vector3.y)
}

// double z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline double Vector3::_internal_z() const {
  return z_;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:scene_format.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Vector3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:scene_format.Vector3.z)
}

// -------------------------------------------------------------------

// Color

// double r = 1;
inline void Color::clear_r() {
  r_ = 0;
}
inline double Color::_internal_r() const {
  return r_;
}
inline double Color::r() const {
  // @@protoc_insertion_point(field_get:scene_format.Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(double value) {
  
  r_ = value;
}
inline void Color::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:scene_format.Color.r)
}

// double g = 2;
inline void Color::clear_g() {
  g_ = 0;
}
inline double Color::_internal_g() const {
  return g_;
}
inline double Color::g() const {
  // @@protoc_insertion_point(field_get:scene_format.Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(double value) {
  
  g_ = value;
}
inline void Color::set_g(double value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:scene_format.Color.g)
}

// double b = 3;
inline void Color::clear_b() {
  b_ = 0;
}
inline double Color::_internal_b() const {
  return b_;
}
inline double Color::b() const {
  // @@protoc_insertion_point(field_get:scene_format.Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(double value) {
  
  b_ = value;
}
inline void Color::set_b(double value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:scene_format.Color.b)
}

// -------------------------------------------------------------------

// Transform

// .scene_format.Vector3 position = 2;
inline bool Transform::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Transform::has_position() const {
  return _internal_has_position();
}
inline void Transform::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::scene_format::Vector3& Transform::_internal_position() const {
  const ::scene_format::Vector3* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Vector3&>(
      ::scene_format::_Vector3_default_instance_);
}
inline const ::scene_format::Vector3& Transform::position() const {
  // @@protoc_insertion_point(field_get:scene_format.Transform.position)
  return _internal_position();
}
inline void Transform::unsafe_arena_set_allocated_position(
    ::scene_format::Vector3* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Transform.position)
}
inline ::scene_format::Vector3* Transform::release_position() {
  
  ::scene_format::Vector3* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Vector3* Transform::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:scene_format.Transform.position)
  
  ::scene_format::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::scene_format::Vector3* Transform::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Vector3>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::scene_format::Vector3* Transform::mutable_position() {
  // @@protoc_insertion_point(field_mutable:scene_format.Transform.position)
  return _internal_mutable_position();
}
inline void Transform::set_allocated_position(::scene_format::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Transform.position)
}

// .scene_format.Vector3 rotation = 3;
inline bool Transform::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool Transform::has_rotation() const {
  return _internal_has_rotation();
}
inline void Transform::clear_rotation() {
  if (GetArena() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::scene_format::Vector3& Transform::_internal_rotation() const {
  const ::scene_format::Vector3* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Vector3&>(
      ::scene_format::_Vector3_default_instance_);
}
inline const ::scene_format::Vector3& Transform::rotation() const {
  // @@protoc_insertion_point(field_get:scene_format.Transform.rotation)
  return _internal_rotation();
}
inline void Transform::unsafe_arena_set_allocated_rotation(
    ::scene_format::Vector3* rotation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Transform.rotation)
}
inline ::scene_format::Vector3* Transform::release_rotation() {
  
  ::scene_format::Vector3* temp = rotation_;
  rotation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Vector3* Transform::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:scene_format.Transform.rotation)
  
  ::scene_format::Vector3* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::scene_format::Vector3* Transform::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Vector3>(GetArena());
    rotation_ = p;
  }
  return rotation_;
}
inline ::scene_format::Vector3* Transform::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:scene_format.Transform.rotation)
  return _internal_mutable_rotation();
}
inline void Transform::set_allocated_rotation(::scene_format::Vector3* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Transform.rotation)
}

// .scene_format.Vector3 scale = 4;
inline bool Transform::_internal_has_scale() const {
  return this != internal_default_instance() && scale_ != nullptr;
}
inline bool Transform::has_scale() const {
  return _internal_has_scale();
}
inline void Transform::clear_scale() {
  if (GetArena() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
}
inline const ::scene_format::Vector3& Transform::_internal_scale() const {
  const ::scene_format::Vector3* p = scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Vector3&>(
      ::scene_format::_Vector3_default_instance_);
}
inline const ::scene_format::Vector3& Transform::scale() const {
  // @@protoc_insertion_point(field_get:scene_format.Transform.scale)
  return _internal_scale();
}
inline void Transform::unsafe_arena_set_allocated_scale(
    ::scene_format::Vector3* scale) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scale_);
  }
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Transform.scale)
}
inline ::scene_format::Vector3* Transform::release_scale() {
  
  ::scene_format::Vector3* temp = scale_;
  scale_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Vector3* Transform::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:scene_format.Transform.scale)
  
  ::scene_format::Vector3* temp = scale_;
  scale_ = nullptr;
  return temp;
}
inline ::scene_format::Vector3* Transform::_internal_mutable_scale() {
  
  if (scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Vector3>(GetArena());
    scale_ = p;
  }
  return scale_;
}
inline ::scene_format::Vector3* Transform::mutable_scale() {
  // @@protoc_insertion_point(field_mutable:scene_format.Transform.scale)
  return _internal_mutable_scale();
}
inline void Transform::set_allocated_scale(::scene_format::Vector3* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Transform.scale)
}

// int32 parent_id = 5;
inline void Transform::clear_parent_id() {
  parent_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Transform::_internal_parent_id() const {
  return parent_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Transform::parent_id() const {
  // @@protoc_insertion_point(field_get:scene_format.Transform.parent_id)
  return _internal_parent_id();
}
inline void Transform::_internal_set_parent_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  parent_id_ = value;
}
inline void Transform::set_parent_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:scene_format.Transform.parent_id)
}

// -------------------------------------------------------------------

// RenderOptions

// int32 camera_id = 1;
inline void RenderOptions::clear_camera_id() {
  camera_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RenderOptions::_internal_camera_id() const {
  return camera_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RenderOptions::camera_id() const {
  // @@protoc_insertion_point(field_get:scene_format.RenderOptions.camera_id)
  return _internal_camera_id();
}
inline void RenderOptions::_internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  camera_id_ = value;
}
inline void RenderOptions::set_camera_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:scene_format.RenderOptions.camera_id)
}

// int32 width = 2;
inline void RenderOptions::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RenderOptions::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RenderOptions::width() const {
  // @@protoc_insertion_point(field_get:scene_format.RenderOptions.width)
  return _internal_width();
}
inline void RenderOptions::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void RenderOptions::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:scene_format.RenderOptions.width)
}

// int32 height = 3;
inline void RenderOptions::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RenderOptions::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RenderOptions::height() const {
  // @@protoc_insertion_point(field_get:scene_format.RenderOptions.height)
  return _internal_height();
}
inline void RenderOptions::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void RenderOptions::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:scene_format.RenderOptions.height)
}

// repeated .scene_format.CustomProperty custom_properties = 4;
inline int RenderOptions::_internal_custom_properties_size() const {
  return custom_properties_.size();
}
inline int RenderOptions::custom_properties_size() const {
  return _internal_custom_properties_size();
}
inline void RenderOptions::clear_custom_properties() {
  custom_properties_.Clear();
}
inline ::scene_format::CustomProperty* RenderOptions::mutable_custom_properties(int index) {
  // @@protoc_insertion_point(field_mutable:scene_format.RenderOptions.custom_properties)
  return custom_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::CustomProperty >*
RenderOptions::mutable_custom_properties() {
  // @@protoc_insertion_point(field_mutable_list:scene_format.RenderOptions.custom_properties)
  return &custom_properties_;
}
inline const ::scene_format::CustomProperty& RenderOptions::_internal_custom_properties(int index) const {
  return custom_properties_.Get(index);
}
inline const ::scene_format::CustomProperty& RenderOptions::custom_properties(int index) const {
  // @@protoc_insertion_point(field_get:scene_format.RenderOptions.custom_properties)
  return _internal_custom_properties(index);
}
inline ::scene_format::CustomProperty* RenderOptions::_internal_add_custom_properties() {
  return custom_properties_.Add();
}
inline ::scene_format::CustomProperty* RenderOptions::add_custom_properties() {
  // @@protoc_insertion_point(field_add:scene_format.RenderOptions.custom_properties)
  return _internal_add_custom_properties();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::scene_format::CustomProperty >&
RenderOptions::custom_properties() const {
  // @@protoc_insertion_point(field_list:scene_format.RenderOptions.custom_properties)
  return custom_properties_;
}

// -------------------------------------------------------------------

// Cube

// .scene_format.Vector3 size = 1;
inline bool Cube::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Cube::has_size() const {
  return _internal_has_size();
}
inline void Cube::clear_size() {
  if (GetArena() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::scene_format::Vector3& Cube::_internal_size() const {
  const ::scene_format::Vector3* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Vector3&>(
      ::scene_format::_Vector3_default_instance_);
}
inline const ::scene_format::Vector3& Cube::size() const {
  // @@protoc_insertion_point(field_get:scene_format.Cube.size)
  return _internal_size();
}
inline void Cube::unsafe_arena_set_allocated_size(
    ::scene_format::Vector3* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Cube.size)
}
inline ::scene_format::Vector3* Cube::release_size() {
  
  ::scene_format::Vector3* temp = size_;
  size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Vector3* Cube::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:scene_format.Cube.size)
  
  ::scene_format::Vector3* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::scene_format::Vector3* Cube::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Vector3>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::scene_format::Vector3* Cube::mutable_size() {
  // @@protoc_insertion_point(field_mutable:scene_format.Cube.size)
  return _internal_mutable_size();
}
inline void Cube::set_allocated_size(::scene_format::Vector3* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Cube.size)
}

// -------------------------------------------------------------------

// Sphere

// double radius = 1;
inline void Sphere::clear_radius() {
  radius_ = 0;
}
inline double Sphere::_internal_radius() const {
  return radius_;
}
inline double Sphere::radius() const {
  // @@protoc_insertion_point(field_get:scene_format.Sphere.radius)
  return _internal_radius();
}
inline void Sphere::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void Sphere::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:scene_format.Sphere.radius)
}

// -------------------------------------------------------------------

// Plane

// -------------------------------------------------------------------

// Disk

// double radius = 1;
inline void Disk::clear_radius() {
  radius_ = 0;
}
inline double Disk::_internal_radius() const {
  return radius_;
}
inline double Disk::radius() const {
  // @@protoc_insertion_point(field_get:scene_format.Disk.radius)
  return _internal_radius();
}
inline void Disk::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void Disk::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:scene_format.Disk.radius)
}

// -------------------------------------------------------------------

// MeshedObject

// string reference = 2;
inline void MeshedObject::clear_reference() {
  reference_.ClearToEmpty();
}
inline const std::string& MeshedObject::reference() const {
  // @@protoc_insertion_point(field_get:scene_format.MeshedObject.reference)
  return _internal_reference();
}
inline void MeshedObject::set_reference(const std::string& value) {
  _internal_set_reference(value);
  // @@protoc_insertion_point(field_set:scene_format.MeshedObject.reference)
}
inline std::string* MeshedObject::mutable_reference() {
  // @@protoc_insertion_point(field_mutable:scene_format.MeshedObject.reference)
  return _internal_mutable_reference();
}
inline const std::string& MeshedObject::_internal_reference() const {
  return reference_.Get();
}
inline void MeshedObject::_internal_set_reference(const std::string& value) {
  
  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MeshedObject::set_reference(std::string&& value) {
  
  reference_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:scene_format.MeshedObject.reference)
}
inline void MeshedObject::set_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:scene_format.MeshedObject.reference)
}
inline void MeshedObject::set_reference(const char* value,
    size_t size) {
  
  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:scene_format.MeshedObject.reference)
}
inline std::string* MeshedObject::_internal_mutable_reference() {
  
  return reference_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MeshedObject::release_reference() {
  // @@protoc_insertion_point(field_release:scene_format.MeshedObject.reference)
  return reference_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MeshedObject::set_allocated_reference(std::string* reference) {
  if (reference != nullptr) {
    
  } else {
    
  }
  reference_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reference,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:scene_format.MeshedObject.reference)
}

// -------------------------------------------------------------------

// SceneObject

// int32 id = 1;
inline void SceneObject::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SceneObject::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SceneObject::id() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.id)
  return _internal_id();
}
inline void SceneObject::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void SceneObject::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:scene_format.SceneObject.id)
}

// .scene_format.Transform transform = 2;
inline bool SceneObject::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool SceneObject::has_transform() const {
  return _internal_has_transform();
}
inline void SceneObject::clear_transform() {
  if (GetArena() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::scene_format::Transform& SceneObject::_internal_transform() const {
  const ::scene_format::Transform* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Transform&>(
      ::scene_format::_Transform_default_instance_);
}
inline const ::scene_format::Transform& SceneObject::transform() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.transform)
  return _internal_transform();
}
inline void SceneObject::unsafe_arena_set_allocated_transform(
    ::scene_format::Transform* transform) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.SceneObject.transform)
}
inline ::scene_format::Transform* SceneObject::release_transform() {
  
  ::scene_format::Transform* temp = transform_;
  transform_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Transform* SceneObject::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.transform)
  
  ::scene_format::Transform* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::scene_format::Transform* SceneObject::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Transform>(GetArena());
    transform_ = p;
  }
  return transform_;
}
inline ::scene_format::Transform* SceneObject::mutable_transform() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.transform)
  return _internal_mutable_transform();
}
inline void SceneObject::set_allocated_transform(::scene_format::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:scene_format.SceneObject.transform)
}

// string material_id = 3;
inline bool SceneObject::_internal_has_material_id() const {
  return object_material_case() == kMaterialId;
}
inline bool SceneObject::has_material_id() const {
  return _internal_has_material_id();
}
inline void SceneObject::set_has_material_id() {
  _oneof_case_[0] = kMaterialId;
}
inline void SceneObject::clear_material_id() {
  if (_internal_has_material_id()) {
    object_material_.material_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_object_material();
  }
}
inline const std::string& SceneObject::material_id() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.material_id)
  return _internal_material_id();
}
inline void SceneObject::set_material_id(const std::string& value) {
  _internal_set_material_id(value);
  // @@protoc_insertion_point(field_set:scene_format.SceneObject.material_id)
}
inline std::string* SceneObject::mutable_material_id() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.material_id)
  return _internal_mutable_material_id();
}
inline const std::string& SceneObject::_internal_material_id() const {
  if (_internal_has_material_id()) {
    return object_material_.material_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SceneObject::_internal_set_material_id(const std::string& value) {
  if (!_internal_has_material_id()) {
    clear_object_material();
    set_has_material_id();
    object_material_.material_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  object_material_.material_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SceneObject::set_material_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:scene_format.SceneObject.material_id)
  if (!_internal_has_material_id()) {
    clear_object_material();
    set_has_material_id();
    object_material_.material_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  object_material_.material_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:scene_format.SceneObject.material_id)
}
inline void SceneObject::set_material_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_material_id()) {
    clear_object_material();
    set_has_material_id();
    object_material_.material_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  object_material_.material_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:scene_format.SceneObject.material_id)
}
inline void SceneObject::set_material_id(const char* value,
                             size_t size) {
  if (!_internal_has_material_id()) {
    clear_object_material();
    set_has_material_id();
    object_material_.material_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  object_material_.material_id_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:scene_format.SceneObject.material_id)
}
inline std::string* SceneObject::_internal_mutable_material_id() {
  if (!_internal_has_material_id()) {
    clear_object_material();
    set_has_material_id();
    object_material_.material_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return object_material_.material_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SceneObject::release_material_id() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.material_id)
  if (_internal_has_material_id()) {
    clear_has_object_material();
    return object_material_.material_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void SceneObject::set_allocated_material_id(std::string* material_id) {
  if (has_object_material()) {
    clear_object_material();
  }
  if (material_id != nullptr) {
    set_has_material_id();
    object_material_.material_id_.UnsafeSetDefault(material_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(material_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:scene_format.SceneObject.material_id)
}

// .scene_format.Material material = 4;
inline bool SceneObject::_internal_has_material() const {
  return object_material_case() == kMaterial;
}
inline bool SceneObject::has_material() const {
  return _internal_has_material();
}
inline void SceneObject::set_has_material() {
  _oneof_case_[0] = kMaterial;
}
inline void SceneObject::clear_material() {
  if (_internal_has_material()) {
    if (GetArena() == nullptr) {
      delete object_material_.material_;
    }
    clear_has_object_material();
  }
}
inline ::scene_format::Material* SceneObject::release_material() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.material)
  if (_internal_has_material()) {
    clear_has_object_material();
      ::scene_format::Material* temp = object_material_.material_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_material_.material_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::Material& SceneObject::_internal_material() const {
  return _internal_has_material()
      ? *object_material_.material_
      : reinterpret_cast< ::scene_format::Material&>(::scene_format::_Material_default_instance_);
}
inline const ::scene_format::Material& SceneObject::material() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.material)
  return _internal_material();
}
inline ::scene_format::Material* SceneObject::unsafe_arena_release_material() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.SceneObject.material)
  if (_internal_has_material()) {
    clear_has_object_material();
    ::scene_format::Material* temp = object_material_.material_;
    object_material_.material_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneObject::unsafe_arena_set_allocated_material(::scene_format::Material* material) {
  clear_object_material();
  if (material) {
    set_has_material();
    object_material_.material_ = material;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.SceneObject.material)
}
inline ::scene_format::Material* SceneObject::_internal_mutable_material() {
  if (!_internal_has_material()) {
    clear_object_material();
    set_has_material();
    object_material_.material_ = CreateMaybeMessage< ::scene_format::Material >(GetArena());
  }
  return object_material_.material_;
}
inline ::scene_format::Material* SceneObject::mutable_material() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.material)
  return _internal_mutable_material();
}

// .scene_format.Sphere sphere = 5;
inline bool SceneObject::_internal_has_sphere() const {
  return mesh_case() == kSphere;
}
inline bool SceneObject::has_sphere() const {
  return _internal_has_sphere();
}
inline void SceneObject::set_has_sphere() {
  _oneof_case_[1] = kSphere;
}
inline void SceneObject::clear_sphere() {
  if (_internal_has_sphere()) {
    if (GetArena() == nullptr) {
      delete mesh_.sphere_;
    }
    clear_has_mesh();
  }
}
inline ::scene_format::Sphere* SceneObject::release_sphere() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.sphere)
  if (_internal_has_sphere()) {
    clear_has_mesh();
      ::scene_format::Sphere* temp = mesh_.sphere_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mesh_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::Sphere& SceneObject::_internal_sphere() const {
  return _internal_has_sphere()
      ? *mesh_.sphere_
      : reinterpret_cast< ::scene_format::Sphere&>(::scene_format::_Sphere_default_instance_);
}
inline const ::scene_format::Sphere& SceneObject::sphere() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.sphere)
  return _internal_sphere();
}
inline ::scene_format::Sphere* SceneObject::unsafe_arena_release_sphere() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.SceneObject.sphere)
  if (_internal_has_sphere()) {
    clear_has_mesh();
    ::scene_format::Sphere* temp = mesh_.sphere_;
    mesh_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneObject::unsafe_arena_set_allocated_sphere(::scene_format::Sphere* sphere) {
  clear_mesh();
  if (sphere) {
    set_has_sphere();
    mesh_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.SceneObject.sphere)
}
inline ::scene_format::Sphere* SceneObject::_internal_mutable_sphere() {
  if (!_internal_has_sphere()) {
    clear_mesh();
    set_has_sphere();
    mesh_.sphere_ = CreateMaybeMessage< ::scene_format::Sphere >(GetArena());
  }
  return mesh_.sphere_;
}
inline ::scene_format::Sphere* SceneObject::mutable_sphere() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.sphere)
  return _internal_mutable_sphere();
}

// .scene_format.Cube cube = 6;
inline bool SceneObject::_internal_has_cube() const {
  return mesh_case() == kCube;
}
inline bool SceneObject::has_cube() const {
  return _internal_has_cube();
}
inline void SceneObject::set_has_cube() {
  _oneof_case_[1] = kCube;
}
inline void SceneObject::clear_cube() {
  if (_internal_has_cube()) {
    if (GetArena() == nullptr) {
      delete mesh_.cube_;
    }
    clear_has_mesh();
  }
}
inline ::scene_format::Cube* SceneObject::release_cube() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.cube)
  if (_internal_has_cube()) {
    clear_has_mesh();
      ::scene_format::Cube* temp = mesh_.cube_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mesh_.cube_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::Cube& SceneObject::_internal_cube() const {
  return _internal_has_cube()
      ? *mesh_.cube_
      : reinterpret_cast< ::scene_format::Cube&>(::scene_format::_Cube_default_instance_);
}
inline const ::scene_format::Cube& SceneObject::cube() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.cube)
  return _internal_cube();
}
inline ::scene_format::Cube* SceneObject::unsafe_arena_release_cube() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.SceneObject.cube)
  if (_internal_has_cube()) {
    clear_has_mesh();
    ::scene_format::Cube* temp = mesh_.cube_;
    mesh_.cube_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneObject::unsafe_arena_set_allocated_cube(::scene_format::Cube* cube) {
  clear_mesh();
  if (cube) {
    set_has_cube();
    mesh_.cube_ = cube;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.SceneObject.cube)
}
inline ::scene_format::Cube* SceneObject::_internal_mutable_cube() {
  if (!_internal_has_cube()) {
    clear_mesh();
    set_has_cube();
    mesh_.cube_ = CreateMaybeMessage< ::scene_format::Cube >(GetArena());
  }
  return mesh_.cube_;
}
inline ::scene_format::Cube* SceneObject::mutable_cube() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.cube)
  return _internal_mutable_cube();
}

// .scene_format.Plane plane = 7;
inline bool SceneObject::_internal_has_plane() const {
  return mesh_case() == kPlane;
}
inline bool SceneObject::has_plane() const {
  return _internal_has_plane();
}
inline void SceneObject::set_has_plane() {
  _oneof_case_[1] = kPlane;
}
inline void SceneObject::clear_plane() {
  if (_internal_has_plane()) {
    if (GetArena() == nullptr) {
      delete mesh_.plane_;
    }
    clear_has_mesh();
  }
}
inline ::scene_format::Plane* SceneObject::release_plane() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.plane)
  if (_internal_has_plane()) {
    clear_has_mesh();
      ::scene_format::Plane* temp = mesh_.plane_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mesh_.plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::Plane& SceneObject::_internal_plane() const {
  return _internal_has_plane()
      ? *mesh_.plane_
      : reinterpret_cast< ::scene_format::Plane&>(::scene_format::_Plane_default_instance_);
}
inline const ::scene_format::Plane& SceneObject::plane() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.plane)
  return _internal_plane();
}
inline ::scene_format::Plane* SceneObject::unsafe_arena_release_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.SceneObject.plane)
  if (_internal_has_plane()) {
    clear_has_mesh();
    ::scene_format::Plane* temp = mesh_.plane_;
    mesh_.plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneObject::unsafe_arena_set_allocated_plane(::scene_format::Plane* plane) {
  clear_mesh();
  if (plane) {
    set_has_plane();
    mesh_.plane_ = plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.SceneObject.plane)
}
inline ::scene_format::Plane* SceneObject::_internal_mutable_plane() {
  if (!_internal_has_plane()) {
    clear_mesh();
    set_has_plane();
    mesh_.plane_ = CreateMaybeMessage< ::scene_format::Plane >(GetArena());
  }
  return mesh_.plane_;
}
inline ::scene_format::Plane* SceneObject::mutable_plane() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.plane)
  return _internal_mutable_plane();
}

// .scene_format.Disk disk = 8;
inline bool SceneObject::_internal_has_disk() const {
  return mesh_case() == kDisk;
}
inline bool SceneObject::has_disk() const {
  return _internal_has_disk();
}
inline void SceneObject::set_has_disk() {
  _oneof_case_[1] = kDisk;
}
inline void SceneObject::clear_disk() {
  if (_internal_has_disk()) {
    if (GetArena() == nullptr) {
      delete mesh_.disk_;
    }
    clear_has_mesh();
  }
}
inline ::scene_format::Disk* SceneObject::release_disk() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.disk)
  if (_internal_has_disk()) {
    clear_has_mesh();
      ::scene_format::Disk* temp = mesh_.disk_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mesh_.disk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::Disk& SceneObject::_internal_disk() const {
  return _internal_has_disk()
      ? *mesh_.disk_
      : reinterpret_cast< ::scene_format::Disk&>(::scene_format::_Disk_default_instance_);
}
inline const ::scene_format::Disk& SceneObject::disk() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.disk)
  return _internal_disk();
}
inline ::scene_format::Disk* SceneObject::unsafe_arena_release_disk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.SceneObject.disk)
  if (_internal_has_disk()) {
    clear_has_mesh();
    ::scene_format::Disk* temp = mesh_.disk_;
    mesh_.disk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneObject::unsafe_arena_set_allocated_disk(::scene_format::Disk* disk) {
  clear_mesh();
  if (disk) {
    set_has_disk();
    mesh_.disk_ = disk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.SceneObject.disk)
}
inline ::scene_format::Disk* SceneObject::_internal_mutable_disk() {
  if (!_internal_has_disk()) {
    clear_mesh();
    set_has_disk();
    mesh_.disk_ = CreateMaybeMessage< ::scene_format::Disk >(GetArena());
  }
  return mesh_.disk_;
}
inline ::scene_format::Disk* SceneObject::mutable_disk() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.disk)
  return _internal_mutable_disk();
}

// .scene_format.MeshedObject meshed_object = 9;
inline bool SceneObject::_internal_has_meshed_object() const {
  return mesh_case() == kMeshedObject;
}
inline bool SceneObject::has_meshed_object() const {
  return _internal_has_meshed_object();
}
inline void SceneObject::set_has_meshed_object() {
  _oneof_case_[1] = kMeshedObject;
}
inline void SceneObject::clear_meshed_object() {
  if (_internal_has_meshed_object()) {
    if (GetArena() == nullptr) {
      delete mesh_.meshed_object_;
    }
    clear_has_mesh();
  }
}
inline ::scene_format::MeshedObject* SceneObject::release_meshed_object() {
  // @@protoc_insertion_point(field_release:scene_format.SceneObject.meshed_object)
  if (_internal_has_meshed_object()) {
    clear_has_mesh();
      ::scene_format::MeshedObject* temp = mesh_.meshed_object_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mesh_.meshed_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::MeshedObject& SceneObject::_internal_meshed_object() const {
  return _internal_has_meshed_object()
      ? *mesh_.meshed_object_
      : reinterpret_cast< ::scene_format::MeshedObject&>(::scene_format::_MeshedObject_default_instance_);
}
inline const ::scene_format::MeshedObject& SceneObject::meshed_object() const {
  // @@protoc_insertion_point(field_get:scene_format.SceneObject.meshed_object)
  return _internal_meshed_object();
}
inline ::scene_format::MeshedObject* SceneObject::unsafe_arena_release_meshed_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.SceneObject.meshed_object)
  if (_internal_has_meshed_object()) {
    clear_has_mesh();
    ::scene_format::MeshedObject* temp = mesh_.meshed_object_;
    mesh_.meshed_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneObject::unsafe_arena_set_allocated_meshed_object(::scene_format::MeshedObject* meshed_object) {
  clear_mesh();
  if (meshed_object) {
    set_has_meshed_object();
    mesh_.meshed_object_ = meshed_object;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.SceneObject.meshed_object)
}
inline ::scene_format::MeshedObject* SceneObject::_internal_mutable_meshed_object() {
  if (!_internal_has_meshed_object()) {
    clear_mesh();
    set_has_meshed_object();
    mesh_.meshed_object_ = CreateMaybeMessage< ::scene_format::MeshedObject >(GetArena());
  }
  return mesh_.meshed_object_;
}
inline ::scene_format::MeshedObject* SceneObject::mutable_meshed_object() {
  // @@protoc_insertion_point(field_mutable:scene_format.SceneObject.meshed_object)
  return _internal_mutable_meshed_object();
}

inline bool SceneObject::has_object_material() const {
  return object_material_case() != OBJECT_MATERIAL_NOT_SET;
}
inline void SceneObject::clear_has_object_material() {
  _oneof_case_[0] = OBJECT_MATERIAL_NOT_SET;
}
inline bool SceneObject::has_mesh() const {
  return mesh_case() != MESH_NOT_SET;
}
inline void SceneObject::clear_has_mesh() {
  _oneof_case_[1] = MESH_NOT_SET;
}
inline SceneObject::ObjectMaterialCase SceneObject::object_material_case() const {
  return SceneObject::ObjectMaterialCase(_oneof_case_[0]);
}
inline SceneObject::MeshCase SceneObject::mesh_case() const {
  return SceneObject::MeshCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// LightDirectional

// -------------------------------------------------------------------

// LightPoint

// -------------------------------------------------------------------

// LightEnvironment

// -------------------------------------------------------------------

// LightSphere

// double radius = 1;
inline void LightSphere::clear_radius() {
  radius_ = 0;
}
inline double LightSphere::_internal_radius() const {
  return radius_;
}
inline double LightSphere::radius() const {
  // @@protoc_insertion_point(field_get:scene_format.LightSphere.radius)
  return _internal_radius();
}
inline void LightSphere::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void LightSphere::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:scene_format.LightSphere.radius)
}

// -------------------------------------------------------------------

// Light

// int32 id = 1;
inline void Light::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Light::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Light::id() const {
  // @@protoc_insertion_point(field_get:scene_format.Light.id)
  return _internal_id();
}
inline void Light::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void Light::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:scene_format.Light.id)
}

// .scene_format.Transform transform = 3;
inline bool Light::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool Light::has_transform() const {
  return _internal_has_transform();
}
inline void Light::clear_transform() {
  if (GetArena() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::scene_format::Transform& Light::_internal_transform() const {
  const ::scene_format::Transform* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Transform&>(
      ::scene_format::_Transform_default_instance_);
}
inline const ::scene_format::Transform& Light::transform() const {
  // @@protoc_insertion_point(field_get:scene_format.Light.transform)
  return _internal_transform();
}
inline void Light::unsafe_arena_set_allocated_transform(
    ::scene_format::Transform* transform) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Light.transform)
}
inline ::scene_format::Transform* Light::release_transform() {
  
  ::scene_format::Transform* temp = transform_;
  transform_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Transform* Light::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:scene_format.Light.transform)
  
  ::scene_format::Transform* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::scene_format::Transform* Light::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Transform>(GetArena());
    transform_ = p;
  }
  return transform_;
}
inline ::scene_format::Transform* Light::mutable_transform() {
  // @@protoc_insertion_point(field_mutable:scene_format.Light.transform)
  return _internal_mutable_transform();
}
inline void Light::set_allocated_transform(::scene_format::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Light.transform)
}

// .scene_format.Color color = 4;
inline bool Light::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Light::has_color() const {
  return _internal_has_color();
}
inline void Light::clear_color() {
  if (GetArena() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::scene_format::Color& Light::_internal_color() const {
  const ::scene_format::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Color&>(
      ::scene_format::_Color_default_instance_);
}
inline const ::scene_format::Color& Light::color() const {
  // @@protoc_insertion_point(field_get:scene_format.Light.color)
  return _internal_color();
}
inline void Light::unsafe_arena_set_allocated_color(
    ::scene_format::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Light.color)
}
inline ::scene_format::Color* Light::release_color() {
  
  ::scene_format::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Color* Light::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:scene_format.Light.color)
  
  ::scene_format::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::scene_format::Color* Light::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::scene_format::Color* Light::mutable_color() {
  // @@protoc_insertion_point(field_mutable:scene_format.Light.color)
  return _internal_mutable_color();
}
inline void Light::set_allocated_color(::scene_format::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Light.color)
}

// .scene_format.LightPoint point = 5;
inline bool Light::_internal_has_point() const {
  return light_case() == kPoint;
}
inline bool Light::has_point() const {
  return _internal_has_point();
}
inline void Light::set_has_point() {
  _oneof_case_[0] = kPoint;
}
inline void Light::clear_point() {
  if (_internal_has_point()) {
    if (GetArena() == nullptr) {
      delete light_.point_;
    }
    clear_has_light();
  }
}
inline ::scene_format::LightPoint* Light::release_point() {
  // @@protoc_insertion_point(field_release:scene_format.Light.point)
  if (_internal_has_point()) {
    clear_has_light();
      ::scene_format::LightPoint* temp = light_.point_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    light_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::LightPoint& Light::_internal_point() const {
  return _internal_has_point()
      ? *light_.point_
      : reinterpret_cast< ::scene_format::LightPoint&>(::scene_format::_LightPoint_default_instance_);
}
inline const ::scene_format::LightPoint& Light::point() const {
  // @@protoc_insertion_point(field_get:scene_format.Light.point)
  return _internal_point();
}
inline ::scene_format::LightPoint* Light::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Light.point)
  if (_internal_has_point()) {
    clear_has_light();
    ::scene_format::LightPoint* temp = light_.point_;
    light_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Light::unsafe_arena_set_allocated_point(::scene_format::LightPoint* point) {
  clear_light();
  if (point) {
    set_has_point();
    light_.point_ = point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Light.point)
}
inline ::scene_format::LightPoint* Light::_internal_mutable_point() {
  if (!_internal_has_point()) {
    clear_light();
    set_has_point();
    light_.point_ = CreateMaybeMessage< ::scene_format::LightPoint >(GetArena());
  }
  return light_.point_;
}
inline ::scene_format::LightPoint* Light::mutable_point() {
  // @@protoc_insertion_point(field_mutable:scene_format.Light.point)
  return _internal_mutable_point();
}

// .scene_format.LightDirectional directional = 6;
inline bool Light::_internal_has_directional() const {
  return light_case() == kDirectional;
}
inline bool Light::has_directional() const {
  return _internal_has_directional();
}
inline void Light::set_has_directional() {
  _oneof_case_[0] = kDirectional;
}
inline void Light::clear_directional() {
  if (_internal_has_directional()) {
    if (GetArena() == nullptr) {
      delete light_.directional_;
    }
    clear_has_light();
  }
}
inline ::scene_format::LightDirectional* Light::release_directional() {
  // @@protoc_insertion_point(field_release:scene_format.Light.directional)
  if (_internal_has_directional()) {
    clear_has_light();
      ::scene_format::LightDirectional* temp = light_.directional_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    light_.directional_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::LightDirectional& Light::_internal_directional() const {
  return _internal_has_directional()
      ? *light_.directional_
      : reinterpret_cast< ::scene_format::LightDirectional&>(::scene_format::_LightDirectional_default_instance_);
}
inline const ::scene_format::LightDirectional& Light::directional() const {
  // @@protoc_insertion_point(field_get:scene_format.Light.directional)
  return _internal_directional();
}
inline ::scene_format::LightDirectional* Light::unsafe_arena_release_directional() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Light.directional)
  if (_internal_has_directional()) {
    clear_has_light();
    ::scene_format::LightDirectional* temp = light_.directional_;
    light_.directional_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Light::unsafe_arena_set_allocated_directional(::scene_format::LightDirectional* directional) {
  clear_light();
  if (directional) {
    set_has_directional();
    light_.directional_ = directional;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Light.directional)
}
inline ::scene_format::LightDirectional* Light::_internal_mutable_directional() {
  if (!_internal_has_directional()) {
    clear_light();
    set_has_directional();
    light_.directional_ = CreateMaybeMessage< ::scene_format::LightDirectional >(GetArena());
  }
  return light_.directional_;
}
inline ::scene_format::LightDirectional* Light::mutable_directional() {
  // @@protoc_insertion_point(field_mutable:scene_format.Light.directional)
  return _internal_mutable_directional();
}

// .scene_format.LightSphere sphere = 7;
inline bool Light::_internal_has_sphere() const {
  return light_case() == kSphere;
}
inline bool Light::has_sphere() const {
  return _internal_has_sphere();
}
inline void Light::set_has_sphere() {
  _oneof_case_[0] = kSphere;
}
inline void Light::clear_sphere() {
  if (_internal_has_sphere()) {
    if (GetArena() == nullptr) {
      delete light_.sphere_;
    }
    clear_has_light();
  }
}
inline ::scene_format::LightSphere* Light::release_sphere() {
  // @@protoc_insertion_point(field_release:scene_format.Light.sphere)
  if (_internal_has_sphere()) {
    clear_has_light();
      ::scene_format::LightSphere* temp = light_.sphere_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    light_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::LightSphere& Light::_internal_sphere() const {
  return _internal_has_sphere()
      ? *light_.sphere_
      : reinterpret_cast< ::scene_format::LightSphere&>(::scene_format::_LightSphere_default_instance_);
}
inline const ::scene_format::LightSphere& Light::sphere() const {
  // @@protoc_insertion_point(field_get:scene_format.Light.sphere)
  return _internal_sphere();
}
inline ::scene_format::LightSphere* Light::unsafe_arena_release_sphere() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Light.sphere)
  if (_internal_has_sphere()) {
    clear_has_light();
    ::scene_format::LightSphere* temp = light_.sphere_;
    light_.sphere_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Light::unsafe_arena_set_allocated_sphere(::scene_format::LightSphere* sphere) {
  clear_light();
  if (sphere) {
    set_has_sphere();
    light_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Light.sphere)
}
inline ::scene_format::LightSphere* Light::_internal_mutable_sphere() {
  if (!_internal_has_sphere()) {
    clear_light();
    set_has_sphere();
    light_.sphere_ = CreateMaybeMessage< ::scene_format::LightSphere >(GetArena());
  }
  return light_.sphere_;
}
inline ::scene_format::LightSphere* Light::mutable_sphere() {
  // @@protoc_insertion_point(field_mutable:scene_format.Light.sphere)
  return _internal_mutable_sphere();
}

// .scene_format.LightEnvironment environment = 8;
inline bool Light::_internal_has_environment() const {
  return light_case() == kEnvironment;
}
inline bool Light::has_environment() const {
  return _internal_has_environment();
}
inline void Light::set_has_environment() {
  _oneof_case_[0] = kEnvironment;
}
inline void Light::clear_environment() {
  if (_internal_has_environment()) {
    if (GetArena() == nullptr) {
      delete light_.environment_;
    }
    clear_has_light();
  }
}
inline ::scene_format::LightEnvironment* Light::release_environment() {
  // @@protoc_insertion_point(field_release:scene_format.Light.environment)
  if (_internal_has_environment()) {
    clear_has_light();
      ::scene_format::LightEnvironment* temp = light_.environment_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    light_.environment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::LightEnvironment& Light::_internal_environment() const {
  return _internal_has_environment()
      ? *light_.environment_
      : reinterpret_cast< ::scene_format::LightEnvironment&>(::scene_format::_LightEnvironment_default_instance_);
}
inline const ::scene_format::LightEnvironment& Light::environment() const {
  // @@protoc_insertion_point(field_get:scene_format.Light.environment)
  return _internal_environment();
}
inline ::scene_format::LightEnvironment* Light::unsafe_arena_release_environment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Light.environment)
  if (_internal_has_environment()) {
    clear_has_light();
    ::scene_format::LightEnvironment* temp = light_.environment_;
    light_.environment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Light::unsafe_arena_set_allocated_environment(::scene_format::LightEnvironment* environment) {
  clear_light();
  if (environment) {
    set_has_environment();
    light_.environment_ = environment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Light.environment)
}
inline ::scene_format::LightEnvironment* Light::_internal_mutable_environment() {
  if (!_internal_has_environment()) {
    clear_light();
    set_has_environment();
    light_.environment_ = CreateMaybeMessage< ::scene_format::LightEnvironment >(GetArena());
  }
  return light_.environment_;
}
inline ::scene_format::LightEnvironment* Light::mutable_environment() {
  // @@protoc_insertion_point(field_mutable:scene_format.Light.environment)
  return _internal_mutable_environment();
}

inline bool Light::has_light() const {
  return light_case() != LIGHT_NOT_SET;
}
inline void Light::clear_has_light() {
  _oneof_case_[0] = LIGHT_NOT_SET;
}
inline Light::LightCase Light::light_case() const {
  return Light::LightCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PerspectiveCamera

// double fov = 1;
inline void PerspectiveCamera::clear_fov() {
  fov_ = 0;
}
inline double PerspectiveCamera::_internal_fov() const {
  return fov_;
}
inline double PerspectiveCamera::fov() const {
  // @@protoc_insertion_point(field_get:scene_format.PerspectiveCamera.fov)
  return _internal_fov();
}
inline void PerspectiveCamera::_internal_set_fov(double value) {
  
  fov_ = value;
}
inline void PerspectiveCamera::set_fov(double value) {
  _internal_set_fov(value);
  // @@protoc_insertion_point(field_set:scene_format.PerspectiveCamera.fov)
}

// -------------------------------------------------------------------

// OrthographicCamera

// -------------------------------------------------------------------

// Camera

// int32 id = 1;
inline void Camera::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Camera::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Camera::id() const {
  // @@protoc_insertion_point(field_get:scene_format.Camera.id)
  return _internal_id();
}
inline void Camera::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void Camera::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:scene_format.Camera.id)
}

// .scene_format.Transform transform = 2;
inline bool Camera::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool Camera::has_transform() const {
  return _internal_has_transform();
}
inline void Camera::clear_transform() {
  if (GetArena() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::scene_format::Transform& Camera::_internal_transform() const {
  const ::scene_format::Transform* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Transform&>(
      ::scene_format::_Transform_default_instance_);
}
inline const ::scene_format::Transform& Camera::transform() const {
  // @@protoc_insertion_point(field_get:scene_format.Camera.transform)
  return _internal_transform();
}
inline void Camera::unsafe_arena_set_allocated_transform(
    ::scene_format::Transform* transform) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Camera.transform)
}
inline ::scene_format::Transform* Camera::release_transform() {
  
  ::scene_format::Transform* temp = transform_;
  transform_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Transform* Camera::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:scene_format.Camera.transform)
  
  ::scene_format::Transform* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::scene_format::Transform* Camera::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Transform>(GetArena());
    transform_ = p;
  }
  return transform_;
}
inline ::scene_format::Transform* Camera::mutable_transform() {
  // @@protoc_insertion_point(field_mutable:scene_format.Camera.transform)
  return _internal_mutable_transform();
}
inline void Camera::set_allocated_transform(::scene_format::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:scene_format.Camera.transform)
}

// .scene_format.PerspectiveCamera perspective = 3;
inline bool Camera::_internal_has_perspective() const {
  return camera_case() == kPerspective;
}
inline bool Camera::has_perspective() const {
  return _internal_has_perspective();
}
inline void Camera::set_has_perspective() {
  _oneof_case_[0] = kPerspective;
}
inline void Camera::clear_perspective() {
  if (_internal_has_perspective()) {
    if (GetArena() == nullptr) {
      delete camera_.perspective_;
    }
    clear_has_camera();
  }
}
inline ::scene_format::PerspectiveCamera* Camera::release_perspective() {
  // @@protoc_insertion_point(field_release:scene_format.Camera.perspective)
  if (_internal_has_perspective()) {
    clear_has_camera();
      ::scene_format::PerspectiveCamera* temp = camera_.perspective_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    camera_.perspective_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::PerspectiveCamera& Camera::_internal_perspective() const {
  return _internal_has_perspective()
      ? *camera_.perspective_
      : reinterpret_cast< ::scene_format::PerspectiveCamera&>(::scene_format::_PerspectiveCamera_default_instance_);
}
inline const ::scene_format::PerspectiveCamera& Camera::perspective() const {
  // @@protoc_insertion_point(field_get:scene_format.Camera.perspective)
  return _internal_perspective();
}
inline ::scene_format::PerspectiveCamera* Camera::unsafe_arena_release_perspective() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Camera.perspective)
  if (_internal_has_perspective()) {
    clear_has_camera();
    ::scene_format::PerspectiveCamera* temp = camera_.perspective_;
    camera_.perspective_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Camera::unsafe_arena_set_allocated_perspective(::scene_format::PerspectiveCamera* perspective) {
  clear_camera();
  if (perspective) {
    set_has_perspective();
    camera_.perspective_ = perspective;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Camera.perspective)
}
inline ::scene_format::PerspectiveCamera* Camera::_internal_mutable_perspective() {
  if (!_internal_has_perspective()) {
    clear_camera();
    set_has_perspective();
    camera_.perspective_ = CreateMaybeMessage< ::scene_format::PerspectiveCamera >(GetArena());
  }
  return camera_.perspective_;
}
inline ::scene_format::PerspectiveCamera* Camera::mutable_perspective() {
  // @@protoc_insertion_point(field_mutable:scene_format.Camera.perspective)
  return _internal_mutable_perspective();
}

// .scene_format.OrthographicCamera orthographic = 4;
inline bool Camera::_internal_has_orthographic() const {
  return camera_case() == kOrthographic;
}
inline bool Camera::has_orthographic() const {
  return _internal_has_orthographic();
}
inline void Camera::set_has_orthographic() {
  _oneof_case_[0] = kOrthographic;
}
inline void Camera::clear_orthographic() {
  if (_internal_has_orthographic()) {
    if (GetArena() == nullptr) {
      delete camera_.orthographic_;
    }
    clear_has_camera();
  }
}
inline ::scene_format::OrthographicCamera* Camera::release_orthographic() {
  // @@protoc_insertion_point(field_release:scene_format.Camera.orthographic)
  if (_internal_has_orthographic()) {
    clear_has_camera();
      ::scene_format::OrthographicCamera* temp = camera_.orthographic_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    camera_.orthographic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::OrthographicCamera& Camera::_internal_orthographic() const {
  return _internal_has_orthographic()
      ? *camera_.orthographic_
      : reinterpret_cast< ::scene_format::OrthographicCamera&>(::scene_format::_OrthographicCamera_default_instance_);
}
inline const ::scene_format::OrthographicCamera& Camera::orthographic() const {
  // @@protoc_insertion_point(field_get:scene_format.Camera.orthographic)
  return _internal_orthographic();
}
inline ::scene_format::OrthographicCamera* Camera::unsafe_arena_release_orthographic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Camera.orthographic)
  if (_internal_has_orthographic()) {
    clear_has_camera();
    ::scene_format::OrthographicCamera* temp = camera_.orthographic_;
    camera_.orthographic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Camera::unsafe_arena_set_allocated_orthographic(::scene_format::OrthographicCamera* orthographic) {
  clear_camera();
  if (orthographic) {
    set_has_orthographic();
    camera_.orthographic_ = orthographic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Camera.orthographic)
}
inline ::scene_format::OrthographicCamera* Camera::_internal_mutable_orthographic() {
  if (!_internal_has_orthographic()) {
    clear_camera();
    set_has_orthographic();
    camera_.orthographic_ = CreateMaybeMessage< ::scene_format::OrthographicCamera >(GetArena());
  }
  return camera_.orthographic_;
}
inline ::scene_format::OrthographicCamera* Camera::mutable_orthographic() {
  // @@protoc_insertion_point(field_mutable:scene_format.Camera.orthographic)
  return _internal_mutable_orthographic();
}

inline bool Camera::has_camera() const {
  return camera_case() != CAMERA_NOT_SET;
}
inline void Camera::clear_has_camera() {
  _oneof_case_[0] = CAMERA_NOT_SET;
}
inline Camera::CameraCase Camera::camera_case() const {
  return Camera::CameraCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Material

// string id = 1;
inline void Material::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Material::id() const {
  // @@protoc_insertion_point(field_get:scene_format.Material.id)
  return _internal_id();
}
inline void Material::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:scene_format.Material.id)
}
inline std::string* Material::mutable_id() {
  // @@protoc_insertion_point(field_mutable:scene_format.Material.id)
  return _internal_mutable_id();
}
inline const std::string& Material::_internal_id() const {
  return id_.Get();
}
inline void Material::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Material::set_id(std::string&& value) {
  
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:scene_format.Material.id)
}
inline void Material::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:scene_format.Material.id)
}
inline void Material::set_id(const char* value,
    size_t size) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:scene_format.Material.id)
}
inline std::string* Material::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Material::release_id() {
  // @@protoc_insertion_point(field_release:scene_format.Material.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Material::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:scene_format.Material.id)
}

// .scene_format.LambertReflectionMaterial lambert_reflection = 2;
inline bool Material::_internal_has_lambert_reflection() const {
  return material_case() == kLambertReflection;
}
inline bool Material::has_lambert_reflection() const {
  return _internal_has_lambert_reflection();
}
inline void Material::set_has_lambert_reflection() {
  _oneof_case_[0] = kLambertReflection;
}
inline void Material::clear_lambert_reflection() {
  if (_internal_has_lambert_reflection()) {
    if (GetArena() == nullptr) {
      delete material_.lambert_reflection_;
    }
    clear_has_material();
  }
}
inline ::scene_format::LambertReflectionMaterial* Material::release_lambert_reflection() {
  // @@protoc_insertion_point(field_release:scene_format.Material.lambert_reflection)
  if (_internal_has_lambert_reflection()) {
    clear_has_material();
      ::scene_format::LambertReflectionMaterial* temp = material_.lambert_reflection_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    material_.lambert_reflection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::LambertReflectionMaterial& Material::_internal_lambert_reflection() const {
  return _internal_has_lambert_reflection()
      ? *material_.lambert_reflection_
      : reinterpret_cast< ::scene_format::LambertReflectionMaterial&>(::scene_format::_LambertReflectionMaterial_default_instance_);
}
inline const ::scene_format::LambertReflectionMaterial& Material::lambert_reflection() const {
  // @@protoc_insertion_point(field_get:scene_format.Material.lambert_reflection)
  return _internal_lambert_reflection();
}
inline ::scene_format::LambertReflectionMaterial* Material::unsafe_arena_release_lambert_reflection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Material.lambert_reflection)
  if (_internal_has_lambert_reflection()) {
    clear_has_material();
    ::scene_format::LambertReflectionMaterial* temp = material_.lambert_reflection_;
    material_.lambert_reflection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Material::unsafe_arena_set_allocated_lambert_reflection(::scene_format::LambertReflectionMaterial* lambert_reflection) {
  clear_material();
  if (lambert_reflection) {
    set_has_lambert_reflection();
    material_.lambert_reflection_ = lambert_reflection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Material.lambert_reflection)
}
inline ::scene_format::LambertReflectionMaterial* Material::_internal_mutable_lambert_reflection() {
  if (!_internal_has_lambert_reflection()) {
    clear_material();
    set_has_lambert_reflection();
    material_.lambert_reflection_ = CreateMaybeMessage< ::scene_format::LambertReflectionMaterial >(GetArena());
  }
  return material_.lambert_reflection_;
}
inline ::scene_format::LambertReflectionMaterial* Material::mutable_lambert_reflection() {
  // @@protoc_insertion_point(field_mutable:scene_format.Material.lambert_reflection)
  return _internal_mutable_lambert_reflection();
}

// .scene_format.SpecularReflectionMaterial specular_reflection = 3;
inline bool Material::_internal_has_specular_reflection() const {
  return material_case() == kSpecularReflection;
}
inline bool Material::has_specular_reflection() const {
  return _internal_has_specular_reflection();
}
inline void Material::set_has_specular_reflection() {
  _oneof_case_[0] = kSpecularReflection;
}
inline void Material::clear_specular_reflection() {
  if (_internal_has_specular_reflection()) {
    if (GetArena() == nullptr) {
      delete material_.specular_reflection_;
    }
    clear_has_material();
  }
}
inline ::scene_format::SpecularReflectionMaterial* Material::release_specular_reflection() {
  // @@protoc_insertion_point(field_release:scene_format.Material.specular_reflection)
  if (_internal_has_specular_reflection()) {
    clear_has_material();
      ::scene_format::SpecularReflectionMaterial* temp = material_.specular_reflection_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    material_.specular_reflection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::scene_format::SpecularReflectionMaterial& Material::_internal_specular_reflection() const {
  return _internal_has_specular_reflection()
      ? *material_.specular_reflection_
      : reinterpret_cast< ::scene_format::SpecularReflectionMaterial&>(::scene_format::_SpecularReflectionMaterial_default_instance_);
}
inline const ::scene_format::SpecularReflectionMaterial& Material::specular_reflection() const {
  // @@protoc_insertion_point(field_get:scene_format.Material.specular_reflection)
  return _internal_specular_reflection();
}
inline ::scene_format::SpecularReflectionMaterial* Material::unsafe_arena_release_specular_reflection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scene_format.Material.specular_reflection)
  if (_internal_has_specular_reflection()) {
    clear_has_material();
    ::scene_format::SpecularReflectionMaterial* temp = material_.specular_reflection_;
    material_.specular_reflection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Material::unsafe_arena_set_allocated_specular_reflection(::scene_format::SpecularReflectionMaterial* specular_reflection) {
  clear_material();
  if (specular_reflection) {
    set_has_specular_reflection();
    material_.specular_reflection_ = specular_reflection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.Material.specular_reflection)
}
inline ::scene_format::SpecularReflectionMaterial* Material::_internal_mutable_specular_reflection() {
  if (!_internal_has_specular_reflection()) {
    clear_material();
    set_has_specular_reflection();
    material_.specular_reflection_ = CreateMaybeMessage< ::scene_format::SpecularReflectionMaterial >(GetArena());
  }
  return material_.specular_reflection_;
}
inline ::scene_format::SpecularReflectionMaterial* Material::mutable_specular_reflection() {
  // @@protoc_insertion_point(field_mutable:scene_format.Material.specular_reflection)
  return _internal_mutable_specular_reflection();
}

inline bool Material::has_material() const {
  return material_case() != MATERIAL_NOT_SET;
}
inline void Material::clear_has_material() {
  _oneof_case_[0] = MATERIAL_NOT_SET;
}
inline Material::MaterialCase Material::material_case() const {
  return Material::MaterialCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LambertReflectionMaterial

// .scene_format.Color color = 1;
inline bool LambertReflectionMaterial::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool LambertReflectionMaterial::has_color() const {
  return _internal_has_color();
}
inline void LambertReflectionMaterial::clear_color() {
  if (GetArena() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::scene_format::Color& LambertReflectionMaterial::_internal_color() const {
  const ::scene_format::Color* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::scene_format::Color&>(
      ::scene_format::_Color_default_instance_);
}
inline const ::scene_format::Color& LambertReflectionMaterial::color() const {
  // @@protoc_insertion_point(field_get:scene_format.LambertReflectionMaterial.color)
  return _internal_color();
}
inline void LambertReflectionMaterial::unsafe_arena_set_allocated_color(
    ::scene_format::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scene_format.LambertReflectionMaterial.color)
}
inline ::scene_format::Color* LambertReflectionMaterial::release_color() {
  
  ::scene_format::Color* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::scene_format::Color* LambertReflectionMaterial::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:scene_format.LambertReflectionMaterial.color)
  
  ::scene_format::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::scene_format::Color* LambertReflectionMaterial::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::scene_format::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::scene_format::Color* LambertReflectionMaterial::mutable_color() {
  // @@protoc_insertion_point(field_mutable:scene_format.LambertReflectionMaterial.color)
  return _internal_mutable_color();
}
inline void LambertReflectionMaterial::set_allocated_color(::scene_format::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:scene_format.LambertReflectionMaterial.color)
}

// -------------------------------------------------------------------

// SpecularReflectionMaterial

// double eta = 1;
inline void SpecularReflectionMaterial::clear_eta() {
  eta_ = 0;
}
inline double SpecularReflectionMaterial::_internal_eta() const {
  return eta_;
}
inline double SpecularReflectionMaterial::eta() const {
  // @@protoc_insertion_point(field_get:scene_format.SpecularReflectionMaterial.eta)
  return _internal_eta();
}
inline void SpecularReflectionMaterial::_internal_set_eta(double value) {
  
  eta_ = value;
}
inline void SpecularReflectionMaterial::set_eta(double value) {
  _internal_set_eta(value);
  // @@protoc_insertion_point(field_set:scene_format.SpecularReflectionMaterial.eta)
}

// -------------------------------------------------------------------

// CustomProperty

// string key = 1;
inline void CustomProperty::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& CustomProperty::key() const {
  // @@protoc_insertion_point(field_get:scene_format.CustomProperty.key)
  return _internal_key();
}
inline void CustomProperty::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:scene_format.CustomProperty.key)
}
inline std::string* CustomProperty::mutable_key() {
  // @@protoc_insertion_point(field_mutable:scene_format.CustomProperty.key)
  return _internal_mutable_key();
}
inline const std::string& CustomProperty::_internal_key() const {
  return key_.Get();
}
inline void CustomProperty::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomProperty::set_key(std::string&& value) {
  
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:scene_format.CustomProperty.key)
}
inline void CustomProperty::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:scene_format.CustomProperty.key)
}
inline void CustomProperty::set_key(const char* value,
    size_t size) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:scene_format.CustomProperty.key)
}
inline std::string* CustomProperty::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomProperty::release_key() {
  // @@protoc_insertion_point(field_release:scene_format.CustomProperty.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomProperty::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:scene_format.CustomProperty.key)
}

// string text_value = 2;
inline bool CustomProperty::_internal_has_text_value() const {
  return value_case() == kTextValue;
}
inline bool CustomProperty::has_text_value() const {
  return _internal_has_text_value();
}
inline void CustomProperty::set_has_text_value() {
  _oneof_case_[0] = kTextValue;
}
inline void CustomProperty::clear_text_value() {
  if (_internal_has_text_value()) {
    value_.text_value_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_value();
  }
}
inline const std::string& CustomProperty::text_value() const {
  // @@protoc_insertion_point(field_get:scene_format.CustomProperty.text_value)
  return _internal_text_value();
}
inline void CustomProperty::set_text_value(const std::string& value) {
  _internal_set_text_value(value);
  // @@protoc_insertion_point(field_set:scene_format.CustomProperty.text_value)
}
inline std::string* CustomProperty::mutable_text_value() {
  // @@protoc_insertion_point(field_mutable:scene_format.CustomProperty.text_value)
  return _internal_mutable_text_value();
}
inline const std::string& CustomProperty::_internal_text_value() const {
  if (_internal_has_text_value()) {
    return value_.text_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomProperty::_internal_set_text_value(const std::string& value) {
  if (!_internal_has_text_value()) {
    clear_value();
    set_has_text_value();
    value_.text_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.text_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomProperty::set_text_value(std::string&& value) {
  // @@protoc_insertion_point(field_set:scene_format.CustomProperty.text_value)
  if (!_internal_has_text_value()) {
    clear_value();
    set_has_text_value();
    value_.text_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.text_value_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:scene_format.CustomProperty.text_value)
}
inline void CustomProperty::set_text_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_text_value()) {
    clear_value();
    set_has_text_value();
    value_.text_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.text_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:scene_format.CustomProperty.text_value)
}
inline void CustomProperty::set_text_value(const char* value,
                             size_t size) {
  if (!_internal_has_text_value()) {
    clear_value();
    set_has_text_value();
    value_.text_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.text_value_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:scene_format.CustomProperty.text_value)
}
inline std::string* CustomProperty::_internal_mutable_text_value() {
  if (!_internal_has_text_value()) {
    clear_value();
    set_has_text_value();
    value_.text_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.text_value_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomProperty::release_text_value() {
  // @@protoc_insertion_point(field_release:scene_format.CustomProperty.text_value)
  if (_internal_has_text_value()) {
    clear_has_value();
    return value_.text_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void CustomProperty::set_allocated_text_value(std::string* text_value) {
  if (has_value()) {
    clear_value();
  }
  if (text_value != nullptr) {
    set_has_text_value();
    value_.text_value_.UnsafeSetDefault(text_value);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(text_value);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:scene_format.CustomProperty.text_value)
}

// int32 int32_value = 3;
inline bool CustomProperty::_internal_has_int32_value() const {
  return value_case() == kInt32Value;
}
inline bool CustomProperty::has_int32_value() const {
  return _internal_has_int32_value();
}
inline void CustomProperty::set_has_int32_value() {
  _oneof_case_[0] = kInt32Value;
}
inline void CustomProperty::clear_int32_value() {
  if (_internal_has_int32_value()) {
    value_.int32_value_ = 0;
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CustomProperty::_internal_int32_value() const {
  if (_internal_has_int32_value()) {
    return value_.int32_value_;
  }
  return 0;
}
inline void CustomProperty::_internal_set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!_internal_has_int32_value()) {
    clear_value();
    set_has_int32_value();
  }
  value_.int32_value_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CustomProperty::int32_value() const {
  // @@protoc_insertion_point(field_get:scene_format.CustomProperty.int32_value)
  return _internal_int32_value();
}
inline void CustomProperty::set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_int32_value(value);
  // @@protoc_insertion_point(field_set:scene_format.CustomProperty.int32_value)
}

inline bool CustomProperty::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void CustomProperty::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline CustomProperty::ValueCase CustomProperty::value_case() const {
  return CustomProperty::ValueCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace scene_format

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
